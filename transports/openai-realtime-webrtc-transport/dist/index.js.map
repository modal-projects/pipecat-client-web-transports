{"mappings":"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","sources":["transports/openai-realtime-webrtc-transport/src/index.ts","transports/openai-realtime-webrtc-transport/src/OpenAIRealTimeWebRTCTransport.ts"],"sourcesContent":["export * from \"./OpenAIRealTimeWebRTCTransport\";\n","import {\n  LLMContextMessage,\n  LLMFunctionCallData,\n  LLMFunctionCallResultResponse,\n  Participant,\n  PipecatClientOptions,\n  RTVIError,\n  RTVIMessage,\n  RTVIMessageType,\n  Tracks,\n  Transport,\n  TransportStartError,\n  TransportState,\n  logger,\n} from \"@pipecat-ai/client-js\";\n\n// here we use Daily just for input device management\nimport Daily, {\n  DailyCall,\n  DailyEventObjectAvailableDevicesUpdated,\n  DailyEventObjectLocalAudioLevel,\n  DailyEventObjectSelectedDevicesUpdated,\n  DailyEventObjectTrack,\n  DailyParticipant,\n} from \"@daily-co/daily-js\";\n\nimport { dequal } from \"dequal\";\n\nconst BASE_URL = \"https://api.openai.com/v1/realtime\";\nconst MODEL = \"gpt-4o-realtime-preview-2024-12-17\";\n\n/**********************************\n * OpenAI-specific types\n *   types and comments below are based on:\n *     gpt-4o-realtime-preview-2024-12-17\n **********************************/\ntype JSONSchema = { [key: string]: any };\nexport type OpenAIFunctionTool = {\n  type: \"function\";\n  name: string;\n  description: string;\n  parameters: JSONSchema;\n};\n\nexport type OpenAIServerVad = {\n  type: \"server_vad\";\n  create_response?: boolean; // defaults to true\n  interrupt_response?: boolean; // defaults to true\n  prefix_padding_ms?: number; // defaults to 300ms\n  silence_duration_ms?: number; // defaults to 500ms\n  threshold?: number; // range (0.0, 1.0); defaults to 0.5\n};\n\nexport type OpenAISemanticVAD = {\n  type: \"semantic_vad\";\n  eagerness?: \"low\" | \"medium\" | \"high\" | \"auto\"; // defaults to \"auto\", equivalent to \"medium\"\n  create_response?: boolean; // defaults to true\n  interrupt_response?: boolean; // defaults to true\n};\n\nexport type OpenAISessionConfig = Partial<{\n  modalities?: string;\n  instructions?: string;\n  voice?:\n    | \"alloy\"\n    | \"ash\"\n    | \"ballad\"\n    | \"coral\"\n    | \"echo\"\n    | \"sage\"\n    | \"shimmer\"\n    | \"verse\";\n  input_audio_noise_reduction?: {\n    type: \"near_field\" | \"far_field\";\n  } | null; // defaults to null/off\n  input_audio_transcription?: {\n    model: \"whisper-1\" | \"gpt-4o-transcribe\" | \"gpt-4o-mini-transcribe\";\n    language?: string;\n    prompt?: string[] | string; // gpt-4o models take a string\n  } | null; // we default this to gpt-4o-transcribe\n  turn_detection?: OpenAIServerVad | OpenAISemanticVAD | null; // defaults to server_vad\n  temperature?: number;\n  max_tokens?: number | \"inf\";\n  tools?: Array<OpenAIFunctionTool>;\n}>;\n\nexport interface OpenAIServiceOptions {\n  api_key: string;\n  model?: string;\n  initial_messages?: LLMContextMessage[];\n  settings?: OpenAISessionConfig;\n}\n\nexport class OpenAIRealTimeWebRTCTransport extends Transport {\n  declare private _service_options: OpenAIServiceOptions;\n\n  private _openai_channel: RTCDataChannel | null = null;\n  private _openai_cxn: RTCPeerConnection | null = null;\n  private _senders: { [key: string]: RTCRtpSender } = {};\n  private _botTracks: { [key: string]: MediaStreamTrack } = {};\n\n  declare private _daily: DailyCall;\n\n  private _selectedCam: MediaDeviceInfo | Record<string, never> = {};\n  private _selectedMic: MediaDeviceInfo | Record<string, never> = {};\n  private _selectedSpeaker: MediaDeviceInfo | Record<string, never> = {};\n\n  declare private _botIsReadyResolve: {\n    resolve: (value: void | PromiseLike<void>) => void;\n    reject: (reason?: any) => void;\n  } | null;\n\n  constructor(service_options: OpenAIServiceOptions) {\n    super();\n    this._service_options = service_options;\n  }\n\n  // subclasses should implement this method to initialize the LLM\n  // client and call super() on this method\n  initialize(\n    options: PipecatClientOptions,\n    messageHandler: (ev: RTVIMessage) => void,\n  ): void {\n    this._options = options;\n    this._callbacks = options.callbacks ?? {};\n    this._onMessage = messageHandler;\n\n    this._openai_cxn = new RTCPeerConnection();\n\n    const existingInstance = Daily.getCallInstance();\n    if (existingInstance) {\n      this._daily = existingInstance;\n    } else {\n      this._daily = Daily.createCallObject({\n        // Default is cam off\n        startVideoOff: options.enableCam != true,\n        // Default is mic on\n        startAudioOff: options.enableMic == false,\n      });\n      this._attachDeviceListeners();\n    }\n\n    this._attachLLMListeners();\n\n    this.state = \"disconnected\";\n  }\n\n  async initDevices() {\n    if (!this._daily) {\n      throw new RTVIError(\"Transport instance not initialized\");\n    }\n\n    this.state = \"initializing\";\n\n    const infos = await this._daily.startCamera({\n      startVideoOff: true, // !(this._options.enableCam == true),\n      startAudioOff: !(this._options.enableMic ?? true),\n      dailyConfig: { useDevicePreferenceCookies: true },\n    });\n    const { devices } = await this._daily.enumerateDevices();\n    const cams = devices.filter((d) => d.kind === \"videoinput\");\n    const mics = devices.filter((d) => d.kind === \"audioinput\");\n    const speakers = devices.filter((d) => d.kind === \"audiooutput\");\n    this._callbacks.onAvailableCamsUpdated?.(cams);\n    this._callbacks.onAvailableMicsUpdated?.(mics);\n    this._callbacks.onAvailableSpeakersUpdated?.(speakers);\n    this._selectedCam = infos.camera;\n    this._callbacks.onCamUpdated?.(infos.camera as MediaDeviceInfo);\n    this._selectedMic = infos.mic;\n    this._callbacks.onMicUpdated?.(infos.mic as MediaDeviceInfo);\n    this._selectedSpeaker = infos.speaker;\n    this._callbacks.onSpeakerUpdated?.(infos.speaker as MediaDeviceInfo);\n\n    // Instantiate audio observers\n    if (!this._daily.isLocalAudioLevelObserverRunning())\n      await this._daily.startLocalAudioLevelObserver(100);\n\n    this.state = \"initialized\";\n  }\n\n  /**********************************/\n  /** Call Lifecycle functionality */\n  _validateConnectionParams(\n    connectParams: unknown,\n  ): undefined | OpenAIServiceOptions {\n    if (connectParams === undefined || connectParams === null) {\n      return undefined;\n    }\n    if (typeof connectParams !== \"object\") {\n      throw new RTVIError(\"Invalid connection parameters\");\n    }\n    return connectParams as OpenAIServiceOptions;\n  }\n\n  async _connect(): Promise<void> {\n    if (!this._openai_cxn) {\n      logger.error(\n        \"connectLLM called before the webrtc connection is initialized. Be sure to call initializeLLM() first.\",\n      );\n      return;\n    }\n\n    if (this._abortController?.signal.aborted) return;\n\n    this.state = \"connecting\";\n\n    await this._connectLLM();\n\n    if (this._abortController?.signal.aborted) return;\n\n    this.state = \"connected\";\n    this._callbacks.onConnected?.();\n  }\n\n  async _disconnect(): Promise<void> {\n    this.state = \"disconnecting\";\n    await this._disconnectLLM();\n    this.state = \"disconnected\";\n    this._callbacks.onDisconnected?.();\n\n    this.initialize(this._options, this._onMessage);\n  }\n\n  get state(): TransportState {\n    return this._state;\n  }\n\n  private set state(state: TransportState) {\n    if (this._state === state) return;\n\n    this._state = state;\n    this._callbacks.onTransportStateChanged?.(state);\n  }\n\n  /**********************************/\n  /** OpenAI-specific functionality */\n\n  public updateSettings(settings: OpenAISessionConfig) {\n    if (settings.voice && this._channelReady()) {\n      logger.warn(\n        \"changing voice settings after session start is not supported\",\n      );\n      delete settings.voice;\n    }\n    const newSettings = {\n      ...this._service_options.settings,\n      ...settings,\n    };\n    if (dequal(newSettings, this._service_options.settings)) return;\n    this._service_options.settings = {\n      ...this._service_options.settings,\n      ...settings,\n    };\n    this._updateSession();\n  }\n\n  /**********************************/\n  /** Device functionality */\n\n  async getAllMics(): Promise<MediaDeviceInfo[]> {\n    let devices = (await this._daily.enumerateDevices()).devices;\n    return devices.filter((device) => device.kind === \"audioinput\");\n  }\n  async getAllCams(): Promise<MediaDeviceInfo[]> {\n    let devices = (await this._daily.enumerateDevices()).devices;\n    return devices.filter((device) => device.kind === \"videoinput\");\n  }\n  async getAllSpeakers(): Promise<MediaDeviceInfo[]> {\n    let devices = (await this._daily.enumerateDevices()).devices;\n    return devices.filter((device) => device.kind === \"audiooutput\");\n  }\n\n  updateMic(micId: string) {\n    this._daily\n      .setInputDevicesAsync({ audioDeviceId: micId })\n      .then((deviceInfo) => {\n        this._selectedMic = deviceInfo.mic;\n      });\n  }\n  updateCam(camId: string) {\n    this._daily\n      .setInputDevicesAsync({ videoDeviceId: camId })\n      .then((deviceInfo) => {\n        this._selectedCam = deviceInfo.camera;\n      });\n  }\n  updateSpeaker(speakerId: string) {\n    this._daily\n      .setOutputDeviceAsync({ outputDeviceId: speakerId })\n      .then((deviceInfo) => {\n        this._selectedSpeaker = deviceInfo.speaker;\n      });\n  }\n  get selectedMic(): MediaDeviceInfo | Record<string, never> {\n    return this._selectedMic;\n  }\n  get selectedCam(): MediaDeviceInfo | Record<string, never> {\n    return this._selectedCam;\n  }\n  get selectedSpeaker(): MediaDeviceInfo | Record<string, never> {\n    return this._selectedSpeaker;\n  }\n\n  enableMic(enable: boolean): void {\n    if (!this._daily.participants()?.local) return;\n    this._daily.setLocalAudio(enable);\n  }\n  enableCam(enable: boolean): void {\n    if (!this._daily.participants()?.local) return;\n    this._daily.setLocalVideo(enable);\n  }\n\n  get isCamEnabled(): boolean {\n    return this._daily.localVideo();\n  }\n  get isMicEnabled(): boolean {\n    return this._daily.localAudio();\n  }\n\n  // Not implemented\n  enableScreenShare(enable: boolean): void {\n    logger.error(\n      \"startScreenShare not implemented for OpenAIRealTimeWebRTCTransport\",\n    );\n    throw new Error(\"Not implemented\");\n  }\n\n  public get isSharingScreen(): boolean {\n    logger.error(\n      \"isSharingScreen not implemented for OpenAIRealTimeWebRTCTransport\",\n    );\n    return false;\n  }\n\n  tracks(): Tracks {\n    const participants = this._daily?.participants() ?? {};\n\n    const tracks: Tracks = {\n      local: {\n        audio: participants?.local?.tracks?.audio?.persistentTrack,\n        video: participants?.local?.tracks?.video?.persistentTrack,\n      },\n    };\n    if (Object.keys(this._botTracks).length > 0) {\n      tracks.bot = this._botTracks;\n    }\n    return tracks;\n  }\n\n  /**********************************/\n  /** Bot communication */\n  async sendReadyMessage(): Promise<void> {\n    const p = new Promise<void>((resolve, reject) => {\n      if (this.state === \"ready\") {\n        resolve();\n      } else {\n        this._botIsReadyResolve = { resolve, reject };\n      }\n    });\n    try {\n      await p;\n      this._onMessage({\n        type: RTVIMessageType.BOT_READY,\n        data: { version: \"1.0.0\" },\n      } as RTVIMessage);\n    } catch (e) {\n      logger.error(\"Failed to start bot\");\n      throw new TransportStartError();\n    }\n  }\n\n  sendMessage(message: RTVIMessage): void {\n    switch (message.type) {\n      case RTVIMessageType.APPEND_TO_CONTEXT:\n        {\n          const data = message.data as LLMContextMessage;\n          const runImmediately = data.run_immediately ?? false;\n          const messages = [{ content: data.content, role: data.role }];\n          this._sendTextInput(messages, runImmediately);\n        }\n        break;\n      case \"run\":\n        this._run();\n        break;\n      case RTVIMessageType.LLM_FUNCTION_CALL_RESULT: {\n        this._sendFunctionCallResult(\n          message.data as LLMFunctionCallResultResponse,\n        );\n        break;\n      }\n    }\n  }\n\n  /**********************************/\n  /** Private methods */\n  async _connectLLM(): Promise<void> {\n    const audioSender = this._senders[\"audio\"];\n    if (!audioSender) {\n      let micTrack =\n        this._daily.participants()?.local?.tracks?.audio?.persistentTrack;\n      if (!micTrack) {\n        try {\n          const stream = await navigator.mediaDevices.getUserMedia({\n            audio: true,\n          });\n          micTrack = stream.getAudioTracks()[0];\n        } catch (e) {\n          logger.error(\n            \"Failed to get mic track. OpenAI requires audio on initial connection.\",\n            e,\n          );\n          throw new RTVIError(\n            \"Failed to get mic track. OpenAI requires audio on initial connection.\",\n          );\n        }\n      }\n      this._senders[\"audio\"] = this._openai_cxn!.addTrack(micTrack);\n    }\n\n    await this._negotiateConnection();\n  }\n\n  async _disconnectLLM(): Promise<void> {\n    this._cleanup();\n  }\n\n  private _attachDeviceListeners(): void {\n    this._daily.on(\"track-started\", this._handleTrackStarted.bind(this));\n    this._daily.on(\"track-stopped\", this._handleTrackStopped.bind(this));\n    this._daily.on(\n      \"available-devices-updated\",\n      this._handleAvailableDevicesUpdated.bind(this),\n    );\n    this._daily.on(\n      \"selected-devices-updated\",\n      this._handleSelectedDevicesUpdated.bind(this),\n    );\n    this._daily.on(\"local-audio-level\", this._handleLocalAudioLevel.bind(this));\n  }\n\n  private _attachLLMListeners(): void {\n    if (!this._openai_cxn) {\n      logger.error(\n        \"_attachLLMListeners called before the websocket is initialized. Be sure to call initializeLLM() first.\",\n      );\n      return;\n    }\n    this._openai_cxn.ontrack = (e) => {\n      logger.debug(\"[openai] got track from openai\", e);\n      this._botTracks[e.track.kind] = e.track;\n      this._callbacks.onTrackStarted?.(e.track, botParticipant());\n    };\n\n    // Set up data channel for sending and receiving events\n    if (this._openai_channel) {\n      logger.warn('closing existing data channel \"oai-events\"');\n      this._openai_channel.close();\n      this._openai_channel = null;\n    }\n    const dc = this._openai_cxn.createDataChannel(\"oai-events\");\n    dc.addEventListener(\"message\", (e) => {\n      const realtimeEvent = JSON.parse(e.data);\n      this._handleOpenAIMessage(realtimeEvent);\n    });\n    this._openai_channel = dc;\n\n    this._openai_cxn.onconnectionstatechange = (e) => {\n      const state = (e.target as RTCPeerConnection)?.connectionState;\n      logger.debug(`connection state changed to ${state.toUpperCase()}`);\n      switch (state) {\n        case \"closed\":\n        case \"failed\":\n          this.state = \"error\";\n          if (this._botIsReadyResolve) {\n            this._botIsReadyResolve.reject(\n              \"Connection to OpenAI failed. Check your API key.\",\n            );\n            this._botIsReadyResolve = null;\n          } else {\n            this._callbacks.onError?.(\n              RTVIMessage.error(`Connection to OpenAI ${state}`, true),\n            );\n          }\n          // this._cleanup();\n          break;\n      }\n    };\n    this._openai_cxn.onicecandidateerror = (e) => {\n      logger.error(\"ice candidate error\", e);\n    };\n  }\n\n  async _negotiateConnection(): Promise<void> {\n    const cxn = this._openai_cxn!;\n    const service_options = this._service_options as OpenAIServiceOptions;\n    const apiKey = service_options.api_key;\n    if (!apiKey) {\n      logger.error(\"!!! No API key provided in service_options\");\n      return;\n    }\n\n    try {\n      // Start the session using the Session Description Protocol (SDP)\n      const offer = await cxn.createOffer();\n      await cxn.setLocalDescription(offer);\n\n      const model = service_options?.model ?? MODEL;\n\n      const sdpResponse = await fetch(`${BASE_URL}?model=${model}`, {\n        method: \"POST\",\n        body: offer.sdp,\n        headers: {\n          Authorization: `Bearer ${apiKey}`,\n          \"Content-Type\": \"application/sdp\",\n        },\n      });\n\n      const answer = {\n        type: \"answer\" as RTCSdpType,\n        sdp: await sdpResponse.text(),\n      };\n      await cxn.setRemoteDescription(answer);\n    } catch (error) {\n      const msg = `Failed to connect to LLM: ${error}`;\n      logger.error(msg);\n      this.state = \"error\";\n      throw new TransportStartError(msg);\n    }\n  }\n\n  private _cleanup() {\n    this._openai_channel?.close();\n    this._openai_channel = null;\n    this._openai_cxn?.close();\n    this._openai_cxn = null;\n    this._senders = {};\n    this._botTracks = {};\n  }\n\n  private _updateSession() {\n    if (!this._channelReady()) return;\n    const service_options = this._service_options as OpenAIServiceOptions;\n    const session_config = service_options?.settings ?? {};\n    if (session_config.input_audio_transcription === undefined) {\n      session_config.input_audio_transcription = { model: \"gpt-4o-transcribe\" };\n    }\n    logger.debug(\"updating session\", session_config);\n    this._openai_channel!.send(\n      JSON.stringify({ type: \"session.update\", session: session_config }),\n    );\n    if (service_options?.initial_messages) {\n      this._sendTextInput(service_options.initial_messages, true);\n    }\n  }\n\n  private async _handleOpenAIMessage(msg: Record<string, any>) {\n    const type = msg.type;\n    switch (type) {\n      case \"error\":\n        logger.warn(\"openai error\", msg);\n        // todo: most openai errors are recoverable. For non-recoverable ones\n        // we should throw an RTVIError and disconnect.\n        break;\n      case \"session.created\":\n        this.state = \"ready\";\n        if (this._botIsReadyResolve) {\n          this._botIsReadyResolve.resolve();\n          this._botIsReadyResolve = null;\n        }\n        this._updateSession();\n        break;\n      case \"input_audio_buffer.speech_started\":\n        this._callbacks.onUserStartedSpeaking?.();\n        break;\n      case \"input_audio_buffer.speech_stopped\":\n        this._callbacks.onUserStoppedSpeaking?.();\n        break;\n      case \"conversation.item.input_audio_transcription.completed\":\n        // User transcripts usually arrive after the bot has started speaking again\n        this._callbacks.onUserTranscript?.({\n          text: msg.transcript,\n          final: true,\n          timestamp: Date.now().toString(), //time,\n          user_id: \"user\",\n        });\n        break;\n      case \"response.content_part.added\":\n        if (msg?.part?.type === \"audio\") {\n          this._callbacks.onBotStartedSpeaking?.();\n        }\n        break;\n      case \"output_audio_buffer.cleared\":\n      case \"output_audio_buffer.stopped\":\n        this._callbacks.onBotStoppedSpeaking?.();\n        break;\n      case \"response.audio_transcript.delta\":\n        // There does not seem to be a way to align bot text output with audio. Text\n        // streams faster than audio and all events, and all events are streamed at\n        // LLM output speed.\n        this._callbacks.onBotTtsText?.({ text: msg.delta });\n        break;\n      case \"response.audio_transcript.done\":\n        this._callbacks.onBotTranscript?.({ text: msg.transcript });\n        break;\n      case \"response.function_call_arguments.done\":\n        {\n          let data: LLMFunctionCallData = {\n            function_name: msg.name,\n            tool_call_id: msg.call_id,\n            args: JSON.parse(msg.arguments),\n          };\n          this._onMessage({\n            type: RTVIMessageType.LLM_FUNCTION_CALL,\n            data,\n          } as RTVIMessage);\n        }\n        break;\n      case \"response.function_call_arguments.delta\":\n      default:\n        logger.debug(\"ignoring openai message\", msg);\n    }\n  }\n\n  private async _handleTrackStarted(ev: DailyEventObjectTrack) {\n    const sender = this._senders[ev.track.kind];\n    if (sender) {\n      if (sender.track?.id !== ev.track.id) {\n        sender.replaceTrack(ev.track);\n      }\n    } else {\n      this._senders[ev.track.kind] = this._openai_cxn!.addTrack(ev.track);\n    }\n    this._callbacks.onTrackStarted?.(\n      ev.track,\n      ev.participant\n        ? dailyParticipantToParticipant(ev.participant)\n        : undefined,\n    );\n  }\n\n  private async _handleTrackStopped(ev: DailyEventObjectTrack) {\n    this._callbacks.onTrackStopped?.(\n      ev.track,\n      ev.participant\n        ? dailyParticipantToParticipant(ev.participant)\n        : undefined,\n    );\n  }\n\n  private _handleAvailableDevicesUpdated(\n    ev: DailyEventObjectAvailableDevicesUpdated,\n  ) {\n    this._callbacks.onAvailableCamsUpdated?.(\n      ev.availableDevices.filter((d) => d.kind === \"videoinput\"),\n    );\n    this._callbacks.onAvailableMicsUpdated?.(\n      ev.availableDevices.filter((d) => d.kind === \"audioinput\"),\n    );\n    this._callbacks.onAvailableSpeakersUpdated?.(\n      ev.availableDevices.filter((d) => d.kind === \"audiooutput\"),\n    );\n  }\n\n  private _handleSelectedDevicesUpdated(\n    ev: DailyEventObjectSelectedDevicesUpdated,\n  ) {\n    if (this._selectedCam?.deviceId !== ev.devices.camera) {\n      this._selectedCam = ev.devices.camera;\n      this._callbacks.onCamUpdated?.(ev.devices.camera as MediaDeviceInfo);\n    }\n    if (this._selectedMic?.deviceId !== ev.devices.mic) {\n      this._selectedMic = ev.devices.mic;\n      this._callbacks.onMicUpdated?.(ev.devices.mic as MediaDeviceInfo);\n    }\n    if (this._selectedSpeaker?.deviceId !== ev.devices.speaker) {\n      this._selectedSpeaker = ev.devices.speaker;\n      this._callbacks.onSpeakerUpdated?.(ev.devices.speaker as MediaDeviceInfo);\n    }\n  }\n\n  private _handleLocalAudioLevel(ev: DailyEventObjectLocalAudioLevel) {\n    this._callbacks.onLocalAudioLevel?.(ev.audioLevel);\n  }\n\n  private _sendTextInput(\n    messages: LLMContextMessage[],\n    runImmediately: boolean = false,\n  ) {\n    if (!this._channelReady()) return;\n    messages.forEach((m) => {\n      const event = {\n        type: \"conversation.item.create\",\n        item: {\n          type: \"message\",\n          role: m.role,\n          content: [\n            {\n              type: m.role === \"assistant\" ? \"text\" : \"input_text\",\n              text: m.content,\n            },\n          ],\n        },\n      };\n      this._openai_channel!.send(JSON.stringify(event));\n    });\n    if (runImmediately) {\n      this._run();\n    }\n  }\n\n  private _sendFunctionCallResult(data: LLMFunctionCallResultResponse) {\n    if (!this._channelReady() || !data.result) return;\n    const event = {\n      type: \"conversation.item.create\",\n      item: {\n        type: \"function_call_output\",\n        call_id: data.tool_call_id,\n        output: JSON.stringify(data.result),\n      },\n    };\n    this._openai_channel!.send(JSON.stringify(event));\n    this._run();\n  }\n\n  private _run() {\n    if (!this._channelReady) return;\n    this._openai_channel!.send(JSON.stringify({ type: \"response.create\" }));\n  }\n\n  private _channelReady() {\n    if (!this._openai_channel) return false;\n    return this._openai_channel?.readyState === \"open\";\n  }\n}\n\n/**********************************/\n/** Daily helper functions for device handling */\nconst dailyParticipantToParticipant = (p: DailyParticipant): Participant => ({\n  id: p.user_id,\n  local: p.local,\n  name: p.user_name,\n});\n\nconst botParticipant = () => ({\n  id: \"bot\",\n  local: false,\n  name: \"Bot\",\n});\n"],"names":[],"version":3,"file":"index.js.map"}