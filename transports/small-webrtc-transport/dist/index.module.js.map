{"mappings":"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;A,I,kC,a,U,S,I,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,C,E,S,O,E,M;Q,S,U,K;Y,I;gB,K,U,I,C;Y,E,O,G;gB,O;Y;Q;Q,S,S,K;Y,I;gB,K,S,C,Q,C;Y,E,O,G;gB,O;Y;Q;Q,S,K,M;Y,O,I,G,Q,O,K,I,M,O,K,E,I,C,W;Q;Q,K,A,C,Y,U,K,C,S,c,E,C,E,I;I;A;A,I,oC,a,U,W,I,S,O,E,I;I,I,I;Q,O;Q,M;Y,I,C,C,E,G,G,M,C,C,E;Y,O,C,C,E;Q;Q,M,E;Q,K,E;I,G,G,G,G,I,O,M,C,A,C,O,a,a,W,M,E,S;I,O,E,I,G,K,I,C,C,Q,G,K,I,C,C,S,G,K,I,O,W,c,C,C,C,O,Q,C,G;Q,O,I;I,C,G;I,S,K,C;Q,O,S,C;Y,O,K;gB;gB;a;Q;I;I,S,K,E;Q,I,G,M,I,U;Q,M,K,C,I,G,E,C,E,I,C,I,C,C,G,E,I;Y,I,I,G,K,C,I,E,C,E,G,I,C,C,S,G,E,C,E,G,C,C,Q,I,C,A,C,I,C,C,S,A,K,E,I,C,I,C,I,E,I,A,K,C,A,C,I,E,I,C,G,E,C,E,C,E,I,E,O;Y,I,I,G,G,K;gB,E,C,E,G;gB,E,K;a;Y,O,E,C,E;gB,K;gB,K;oB,I;oB;gB,K;oB,E,K;oB,O;wB,O,E,C,E;wB,M;oB;gB,K;oB,E,K;oB,I,E,C,E;oB,K;wB;qB;oB;gB,K;oB,K,E,G,C,G;oB,E,I,C,G;oB;gB;oB,I,C,C,I,E,I,E,I,E,M,G,K,C,C,E,M,G,E,A,K,C,E,C,E,K,K,E,C,E,K,C,G;wB,I;wB;oB;oB,I,E,C,E,K,K,C,C,K,E,C,E,G,C,C,E,I,E,C,E,G,C,C,E,G;wB,E,K,G,E,C,E;wB;oB;oB,I,E,C,E,K,K,E,K,G,C,C,E,E;wB,E,K,G,C,C,E;wB,I;wB;oB;oB,I,K,E,K,G,C,C,E,E;wB,E,K,G,C,C,E;wB,E,G,C,I,C;wB;oB;oB,I,C,C,E,E,E,G,C,G;oB,E,I,C,G;oB;Y;Y,K,K,I,C,S;Q,E,O,G;Y,K;gB;gB;a;Y,I;Q,S;Y,I,I;Q;Q,I,E,C,E,G,G,M,E,C,E;Q,O;Y,O,E,C,E,G,E,C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AC;YAAK,OAAA,EAAE,QAAQ,KAAK;QAAf;QAC1C,IAAM,gBAAgB,IAAI,CAAC,YAAY,CAAC,eAAe;QACvD,IACE,iBACC,CAAA,CAAC,QAAQ,IAAI,CAAC,SAAC,CAAC;YAAK,OAAA,EAAE,QAAQ,KAAK,cAAc,QAAQ;QAArC,MACnB,cAAc,QAAQ,KAAK,aAC1B,cAAc,KAAK,KAAK,CAAA,kBAAa,QAAb,kBAAa,KAAA,IAAA,KAAA,IAAb,cAAe,KAAK,AAAL,CAAK,GAEhD,IAAI,CAAC,SAAS,CAAC;IAEnB;IAEQ,gBAAA,SAAA,CAAA,kBAAkB,GAA1B,SAA2B,EAQ1B;Q,I,I;QAPC,IAAA,UAAO,GAAA,OAAA,EACP,OAAI,GAAA,IAAA,EACJ,QAAK,GAAA,KAAA;QAML,IAAM,cAAc,IAAI,CAAA,GAAA,kBAAA,EACtB,SACA,MACA,UAAK,QAAL,UAAK,KAAA,IAAA,KAAA,IAAL,MAAO,OAAO,EACd,QAAQ;YAAE,aAAa;QAAK,IAAK;QAEnC,CAAA,KAAA,AAAA,CAAA,KAAA,IAAI,CAAC,UAAU,AAAV,EAAW,aAAa,AAAb,MAAa,QAAA,OAAA,KAAA,KAAA,GAAA,IAAA,CAAA,IAAG;IAClC;IACF,OAAA;AAAA,EA9MqC;AAgNrC,IAAM,yCAAmB;IACvB,OAAO;QACL,IAAI;QACJ,MAAM;QACN,OAAO;IACR;AACH;;;;;;;A,I,kC,a,U,S,I,A;I,I,gB,S,C,E,C;Q,gB,O,c,I,C;Y,W,E;Q,C,a,S,S,C,E,C;Y,E,S,G;Q,K,S,C,E,C;Y,I,I,K,E,I,O,S,C,c,C,I,C,G,I,C,C,E,G,C,C,E;Q;Q,O,c,G;I;I,O,S,C,E,C;Q,I,O,M,c,M,M,M,I,U,yB,O,K;Q,c,G;Q,S;Y,I,C,W,G;Q;Q,E,S,G,M,O,O,M,C,K,C,G,S,G,E,S,E,I,I;I;A;A,I,kC,a,U,S,I,S,O,E,U,E,C,E,S;I,S,M,K;Q,O,iB,I,Q,I,E,S,O;Y,Q;Q;I;I,O,I,C,K,C,I,O,C,E,S,O,E,M;Q,S,U,K;Y,I;gB,K,U,I,C;Y,E,O,G;gB,O;Y;Q;Q,S,S,K;Y,I;gB,K,S,C,Q,C;Y,E,O,G;gB,O;Y;Q;Q,S,K,M;Y,O,I,G,Q,O,K,I,M,O,K,E,I,C,W;Q;Q,K,A,C,Y,U,K,C,S,c,E,C,E,I;I;A;A,I,oC,a,U,W,I,S,O,E,I;I,I,I;Q,O;Q,M;Y,I,C,C,E,G,G,M,C,C,E;Y,O,C,C,E;Q;Q,M,E;Q,K,E;I,G,G,G,G,I,O,M,C,A,C,O,a,a,W,M,E,S;I,O,E,I,G,K,I,C,C,Q,G,K,I,C,C,S,G,K,I,O,W,c,C,C,C,O,Q,C,G;Q,O,I;I,C,G;I,S,K,C;Q,O,S,C;Y,O,K;gB;gB;a;Q;I;I,S,K,E;Q,I,G,M,I,U;Q,M,K,C,I,G,E,C,E,I,C,I,C,C,G,E,I;Y,I,I,G,K,C,I,E,C,E,G,I,C,C,S,G,E,C,E,G,C,C,Q,I,C,A,C,I,C,C,S,A,K,E,I,C,I,C,I,E,I,A,K,C,A,C,I,E,I,C,G,E,C,E,C,E,I,E,O;Y,I,I,G,G,K;gB,E,C,E,G;gB,E,K;a;Y,O,E,C,E;gB,K;gB,K;oB,I;oB;gB,K;oB,E,K;oB,O;wB,O,E,C,E;wB,M;oB;gB,K;oB,E,K;oB,I,E,C,E;oB,K;wB;qB;oB;gB,K;oB,K,E,G,C,G;oB,E,I,C,G;oB;gB;oB,I,C,C,I,E,I,E,I,E,M,G,K,C,C,E,M,G,E,A,K,C,E,C,E,K,K,E,C,E,K,C,G;wB,I;wB;oB;oB,I,E,C,E,K,K,C,C,K,E,C,E,G,C,C,E,I,E,C,E,G,C,C,E,G;wB,E,K,G,E,C,E;wB;oB;oB,I,E,C,E,K,K,E,K,G,C,C,E,E;wB,E,K,G,C,C,E;wB,I;wB;oB;oB,I,K,E,K,G,C,C,E,E;wB,E,K,G,C,C,E;wB,E,G,C,I,C;wB;oB;oB,I,C,C,E,E,E,G,C,G;oB,E,I,C,G;oB;Y;Y,K,K,I,C,S;Q,E,O,G;Y,K;gB;gB;a;Y,I;Q,S;Y,I,I;Q;Q,I,E,C,E,G,G,M,E,C,E;Q,O;Y,O,E,C,E,G,E,C,E,G,K;Y,M;Q;I;A;AU1QA,IAAA,4CAAA,WAAA,GAAA,SAAA,MAAA;IAAuC,gCAAA,mBAAA;IAqBrC,SAAA,kBACE,YAA4B,EAC5B,eAA+B,EAC/B,sBAA+D,EAC/D,sBAA+D,EAC/D,iBAAiD,EACjD,kBAAkC,EAClC,gBAAgC;QANhC,IAAA,iBAAA,K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","sources":["transports/small-webrtc-transport/src/index.ts","lib/media-mgmt/mediaManager.ts","lib/wavtools/index.js","lib/wavtools/lib/wav_packer.js","lib/wavtools/lib/analysis/audio_analysis.js","lib/wavtools/lib/analysis/constants.js","lib/wavtools/lib/wav_stream_player.js","lib/wavtools/lib/worklets/stream_processor.js","lib/wavtools/lib/wav_recorder.js","lib/wavtools/lib/worklets/audio_processor.js","lib/wavtools/lib/mediastream_recorder.js","lib/media-mgmt/dailyMediaManager.ts","transports/small-webrtc-transport/src/smallWebRTCTransport.ts"],"sourcesContent":["import { WavMediaManager } from \"../../../lib/media-mgmt/mediaManager\";\nimport { DailyMediaManager } from \"../../../lib/media-mgmt/dailyMediaManager\";\n\nexport * from \"./smallWebRTCTransport\";\nexport { WavMediaManager, DailyMediaManager };\n","import { WavRecorder, WavStreamPlayer } from \"../wavtools\";\n\nimport {\n  DeviceError,\n  DeviceErrorType,\n  PipecatClientOptions,\n  RTVIEventCallbacks,\n  Tracks,\n} from \"@pipecat-ai/client-js\";\n\nexport abstract class MediaManager {\n  declare protected _userAudioCallback: (data: ArrayBuffer) => void;\n  declare protected _options: PipecatClientOptions;\n  protected _callbacks: RTVIEventCallbacks = {};\n\n  protected _micEnabled: boolean;\n  protected _camEnabled: boolean;\n\n  protected _supportsScreenShare: boolean;\n\n  constructor() {\n    this._micEnabled = true;\n    this._camEnabled = false;\n    this._supportsScreenShare = false;\n  }\n\n  setUserAudioCallback(userAudioCallback: (data: ArrayBuffer) => void) {\n    this._userAudioCallback = userAudioCallback;\n  }\n  setClientOptions(options: PipecatClientOptions, override: boolean = false) {\n    if (this._options && !override) return;\n    this._options = options;\n    this._callbacks = options.callbacks ?? {};\n    this._micEnabled = options.enableMic ?? true;\n    this._camEnabled = options.enableCam ?? false;\n  }\n\n  abstract initialize(): Promise<void>;\n  abstract connect(): Promise<void>;\n  abstract disconnect(): Promise<void>;\n\n  abstract userStartedSpeaking(): Promise<unknown>;\n  abstract bufferBotAudio(\n    data: ArrayBuffer | Int16Array,\n    id?: string,\n  ): Int16Array | undefined;\n\n  abstract getAllMics(): Promise<MediaDeviceInfo[]>;\n  abstract getAllCams(): Promise<MediaDeviceInfo[]>;\n  abstract getAllSpeakers(): Promise<MediaDeviceInfo[]>;\n\n  abstract updateMic(micId: string): void;\n  abstract updateCam(camId: string): void;\n  abstract updateSpeaker(speakerId: string): void;\n\n  abstract get selectedMic(): MediaDeviceInfo | Record<string, never>;\n  abstract get selectedCam(): MediaDeviceInfo | Record<string, never>;\n  abstract get selectedSpeaker(): MediaDeviceInfo | Record<string, never>;\n\n  abstract enableMic(enable: boolean): void;\n  abstract enableCam(enable: boolean): void;\n  abstract enableScreenShare(enable: boolean): void;\n\n  abstract get isCamEnabled(): boolean;\n  abstract get isMicEnabled(): boolean;\n  abstract get isSharingScreen(): boolean;\n\n  abstract tracks(): Tracks;\n\n  get supportsScreenShare(): boolean {\n    return this._supportsScreenShare;\n  }\n}\n\nexport class WavMediaManager extends MediaManager {\n  private _wavRecorder;\n  private _wavStreamPlayer;\n\n  private _initialized = false;\n  private _recorderChunkSize: number | undefined = undefined;\n\n  constructor(\n    recorderChunkSize: number | undefined = undefined,\n    recorderSampleRate: number | undefined = 24000,\n  ) {\n    super();\n    this._recorderChunkSize = recorderChunkSize;\n    this._wavRecorder = new WavRecorder({ sampleRate: recorderSampleRate });\n    this._wavStreamPlayer = new WavStreamPlayer({ sampleRate: 24000 });\n  }\n\n  async initialize(): Promise<void> {\n    try {\n      await this._wavRecorder.begin();\n    } catch (error) {\n      // void. swallow the error. we still want to set up\n      // the listeners and the player.\n    }\n    this._wavRecorder.listenForDeviceChange(null);\n    this._wavRecorder.listenForDeviceChange(\n      this._handleAvailableDevicesUpdated.bind(this),\n    );\n    this._wavRecorder.listenForDeviceErrors(null);\n    this._wavRecorder.listenForDeviceErrors(this._handleDeviceError.bind(this));\n    await this._wavStreamPlayer.connect();\n    this._initialized = true;\n  }\n\n  async connect(): Promise<void> {\n    if (!this._initialized) {\n      await this.initialize();\n    }\n    const isAlreadyRecording = this._wavRecorder.getStatus() == \"recording\";\n    if (this._micEnabled && !isAlreadyRecording) {\n      await this._startRecording();\n    }\n    if (this._camEnabled) {\n      console.warn(\"WavMediaManager does not support video input.\");\n    }\n  }\n\n  async disconnect(): Promise<void> {\n    if (!this._initialized) {\n      return;\n    }\n    await this._wavRecorder.end();\n    await this._wavStreamPlayer.interrupt();\n    this._initialized = false;\n  }\n\n  async userStartedSpeaking(): Promise<unknown> {\n    return this._wavStreamPlayer.interrupt();\n  }\n\n  bufferBotAudio(data: ArrayBuffer | Int16Array, id?: string): Int16Array {\n    return this._wavStreamPlayer.add16BitPCM(data, id);\n  }\n\n  getAllMics(): Promise<MediaDeviceInfo[]> {\n    return this._wavRecorder.listDevices();\n  }\n  getAllCams(): Promise<MediaDeviceInfo[]> {\n    // TODO: Video not supported yet\n    return Promise.resolve([]);\n  }\n  getAllSpeakers(): Promise<MediaDeviceInfo[]> {\n    // TODO: Implement speaker support\n    return Promise.resolve([]);\n  }\n\n  async updateMic(micId: string): Promise<void> {\n    const prevMic = this._wavRecorder.deviceSelection;\n    if (this._wavRecorder.getStatus() !== \"ended\") {\n      await this._wavRecorder.end();\n    }\n    try {\n      await this._wavRecorder.begin(micId);\n      if (this._micEnabled) {\n        await this._startRecording();\n      }\n      const curMic = this._wavRecorder.deviceSelection;\n      if (curMic && prevMic && prevMic.label !== curMic.label) {\n        this._callbacks.onMicUpdated?.(curMic);\n      }\n    } catch (error) {\n      // void. If begin() fails, it will have already logged and called\n      // onDeviceError if necessary.\n    }\n  }\n\n  updateCam(camId: string): void {\n    // TODO: Video not supported yet\n  }\n  updateSpeaker(speakerId: string): void {\n    // TODO: Implement speaker support\n  }\n\n  get selectedMic(): MediaDeviceInfo | Record<string, never> {\n    return this._wavRecorder.deviceSelection ?? {};\n  }\n  get selectedCam(): MediaDeviceInfo | Record<string, never> {\n    // TODO: Video not supported yet\n    return {};\n  }\n  get selectedSpeaker(): MediaDeviceInfo | Record<string, never> {\n    // TODO: Implement speaker support\n    return {};\n  }\n\n  async enableMic(enable: boolean): Promise<void> {\n    this._micEnabled = enable;\n    if (!this._wavRecorder.stream) return;\n    this._wavRecorder.stream\n      .getAudioTracks()\n      .forEach((track: MediaStreamTrack) => {\n        track.enabled = enable;\n        if (!enable) {\n          this._callbacks.onTrackStopped?.(track, localParticipant());\n        }\n      });\n    if (enable) {\n      await this._startRecording();\n    } else {\n      await this._wavRecorder.pause();\n    }\n  }\n  enableCam(enable: boolean): void {\n    // TODO: Video not supported yet\n    console.warn(\"WavMediaManager does not support video input.\");\n  }\n  enableScreenShare(enable: boolean): void {\n    // TODO: Screensharing not supported yet\n    console.warn(\"WavMediaManager does not support screen sharing.\");\n  }\n\n  get isCamEnabled(): boolean {\n    // TODO: Video not supported yet\n    return false;\n  }\n  get isMicEnabled(): boolean {\n    return this._micEnabled;\n  }\n  get isSharingScreen(): boolean {\n    // TODO: Screensharing not supported yet\n    return false;\n  }\n\n  tracks(): Tracks {\n    const tracks = this._wavRecorder.stream?.getTracks()[0];\n    return { local: tracks ? { audio: tracks } : {} };\n  }\n\n  private async _startRecording() {\n    await this._wavRecorder.record((data) => {\n      this._userAudioCallback?.(data.mono);\n    }, this._recorderChunkSize);\n    const track = this._wavRecorder.stream?.getAudioTracks()[0];\n    if (track) {\n      this._callbacks.onTrackStarted?.(track, localParticipant());\n    }\n  }\n\n  private _handleAvailableDevicesUpdated(devices: MediaDeviceInfo[]) {\n    this._callbacks.onAvailableCamsUpdated?.(\n      devices.filter((d) => d.kind === \"videoinput\"),\n    );\n    this._callbacks.onAvailableMicsUpdated?.(\n      devices.filter((d) => d.kind === \"audioinput\"),\n    );\n    // if the current device went away or we're using the default and\n    // the default changed, reset the mic.\n    const defaultDevice = devices.find((d) => d.deviceId === \"default\");\n    const currentDevice = this._wavRecorder.deviceSelection;\n    if (\n      currentDevice &&\n      (!devices.some((d) => d.deviceId === currentDevice.deviceId) ||\n        (currentDevice.deviceId === \"default\" &&\n          currentDevice.label !== defaultDevice?.label))\n    ) {\n      this.updateMic(\"\");\n    }\n  }\n\n  private _handleDeviceError({\n    devices,\n    type,\n    error,\n  }: {\n    devices: Array<\"cam\" | \"mic\">;\n    type: DeviceErrorType;\n    error?: Error;\n  }) {\n    const deviceError = new DeviceError(\n      devices,\n      type,\n      error?.message,\n      error ? { sourceError: error } : undefined,\n    );\n    this._callbacks.onDeviceError?.(deviceError);\n  }\n}\n\nconst localParticipant = () => {\n  return {\n    id: \"local\",\n    name: \"\",\n    local: true,\n  };\n};\n","import { WavPacker } from './lib/wav_packer.js';\nimport { AudioAnalysis } from './lib/analysis/audio_analysis.js';\nimport { WavStreamPlayer } from './lib/wav_stream_player.js';\nimport { WavRecorder } from './lib/wav_recorder.js';\nimport { MediaStreamRecorder } from './lib/mediastream_recorder.js';\n\nexport {\n  AudioAnalysis,\n  MediaStreamRecorder,\n  WavPacker,\n  WavStreamPlayer,\n  WavRecorder,\n};\n","/**\n * Raw wav audio file contents\n * @typedef {Object} WavPackerAudioType\n * @property {Blob} blob\n * @property {string} url\n * @property {number} channelCount\n * @property {number} sampleRate\n * @property {number} duration\n */\n\n/**\n * Utility class for assembling PCM16 \"audio/wav\" data\n * @class\n */\nexport class WavPacker {\n  /**\n   * Converts Float32Array of amplitude data to ArrayBuffer in Int16Array format\n   * @param {Float32Array} float32Array\n   * @returns {ArrayBuffer}\n   */\n  static floatTo16BitPCM(float32Array) {\n    const buffer = new ArrayBuffer(float32Array.length * 2);\n    const view = new DataView(buffer);\n    let offset = 0;\n    for (let i = 0; i < float32Array.length; i++, offset += 2) {\n      let s = Math.max(-1, Math.min(1, float32Array[i]));\n      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n    }\n    return buffer;\n  }\n\n  /**\n   * Concatenates two ArrayBuffers\n   * @param {ArrayBuffer} leftBuffer\n   * @param {ArrayBuffer} rightBuffer\n   * @returns {ArrayBuffer}\n   */\n  static mergeBuffers(leftBuffer, rightBuffer) {\n    const tmpArray = new Uint8Array(\n      leftBuffer.byteLength + rightBuffer.byteLength\n    );\n    tmpArray.set(new Uint8Array(leftBuffer), 0);\n    tmpArray.set(new Uint8Array(rightBuffer), leftBuffer.byteLength);\n    return tmpArray.buffer;\n  }\n\n  /**\n   * Packs data into an Int16 format\n   * @private\n   * @param {number} size 0 = 1x Int16, 1 = 2x Int16\n   * @param {number} arg value to pack\n   * @returns\n   */\n  _packData(size, arg) {\n    return [\n      new Uint8Array([arg, arg >> 8]),\n      new Uint8Array([arg, arg >> 8, arg >> 16, arg >> 24]),\n    ][size];\n  }\n\n  /**\n   * Packs audio into \"audio/wav\" Blob\n   * @param {number} sampleRate\n   * @param {{bitsPerSample: number, channels: Array<Float32Array>, data: Int16Array}} audio\n   * @returns {WavPackerAudioType}\n   */\n  pack(sampleRate, audio) {\n    if (!audio?.bitsPerSample) {\n      throw new Error(`Missing \"bitsPerSample\"`);\n    } else if (!audio?.channels) {\n      throw new Error(`Missing \"channels\"`);\n    } else if (!audio?.data) {\n      throw new Error(`Missing \"data\"`);\n    }\n    const { bitsPerSample, channels, data } = audio;\n    const output = [\n      // Header\n      'RIFF',\n      this._packData(\n        1,\n        4 + (8 + 24) /* chunk 1 length */ + (8 + 8) /* chunk 2 length */\n      ), // Length\n      'WAVE',\n      // chunk 1\n      'fmt ', // Sub-chunk identifier\n      this._packData(1, 16), // Chunk length\n      this._packData(0, 1), // Audio format (1 is linear quantization)\n      this._packData(0, channels.length),\n      this._packData(1, sampleRate),\n      this._packData(1, (sampleRate * channels.length * bitsPerSample) / 8), // Byte rate\n      this._packData(0, (channels.length * bitsPerSample) / 8),\n      this._packData(0, bitsPerSample),\n      // chunk 2\n      'data', // Sub-chunk identifier\n      this._packData(\n        1,\n        (channels[0].length * channels.length * bitsPerSample) / 8\n      ), // Chunk length\n      data,\n    ];\n    const blob = new Blob(output, { type: 'audio/mpeg' });\n    const url = URL.createObjectURL(blob);\n    return {\n      blob,\n      url,\n      channelCount: channels.length,\n      sampleRate,\n      duration: data.byteLength / (channels.length * sampleRate * 2),\n    };\n  }\n}\n\nglobalThis.WavPacker = WavPacker;\n","import {\n  noteFrequencies,\n  noteFrequencyLabels,\n  voiceFrequencies,\n  voiceFrequencyLabels,\n} from './constants.js';\n\n/**\n * Output of AudioAnalysis for the frequency domain of the audio\n * @typedef {Object} AudioAnalysisOutputType\n * @property {Float32Array} values Amplitude of this frequency between {0, 1} inclusive\n * @property {number[]} frequencies Raw frequency bucket values\n * @property {string[]} labels Labels for the frequency bucket values\n */\n\n/**\n * Analyzes audio for visual output\n * @class\n */\nexport class AudioAnalysis {\n  /**\n   * Retrieves frequency domain data from an AnalyserNode adjusted to a decibel range\n   * returns human-readable formatting and labels\n   * @param {AnalyserNode} analyser\n   * @param {number} sampleRate\n   * @param {Float32Array} [fftResult]\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {AudioAnalysisOutputType}\n   */\n  static getFrequencies(\n    analyser,\n    sampleRate,\n    fftResult,\n    analysisType = 'frequency',\n    minDecibels = -100,\n    maxDecibels = -30,\n  ) {\n    if (!fftResult) {\n      fftResult = new Float32Array(analyser.frequencyBinCount);\n      analyser.getFloatFrequencyData(fftResult);\n    }\n    const nyquistFrequency = sampleRate / 2;\n    const frequencyStep = (1 / fftResult.length) * nyquistFrequency;\n    let outputValues;\n    let frequencies;\n    let labels;\n    if (analysisType === 'music' || analysisType === 'voice') {\n      const useFrequencies =\n        analysisType === 'voice' ? voiceFrequencies : noteFrequencies;\n      const aggregateOutput = Array(useFrequencies.length).fill(minDecibels);\n      for (let i = 0; i < fftResult.length; i++) {\n        const frequency = i * frequencyStep;\n        const amplitude = fftResult[i];\n        for (let n = useFrequencies.length - 1; n >= 0; n--) {\n          if (frequency > useFrequencies[n]) {\n            aggregateOutput[n] = Math.max(aggregateOutput[n], amplitude);\n            break;\n          }\n        }\n      }\n      outputValues = aggregateOutput;\n      frequencies =\n        analysisType === 'voice' ? voiceFrequencies : noteFrequencies;\n      labels =\n        analysisType === 'voice' ? voiceFrequencyLabels : noteFrequencyLabels;\n    } else {\n      outputValues = Array.from(fftResult);\n      frequencies = outputValues.map((_, i) => frequencyStep * i);\n      labels = frequencies.map((f) => `${f.toFixed(2)} Hz`);\n    }\n    // We normalize to {0, 1}\n    const normalizedOutput = outputValues.map((v) => {\n      return Math.max(\n        0,\n        Math.min((v - minDecibels) / (maxDecibels - minDecibels), 1),\n      );\n    });\n    const values = new Float32Array(normalizedOutput);\n    return {\n      values,\n      frequencies,\n      labels,\n    };\n  }\n\n  /**\n   * Creates a new AudioAnalysis instance for an HTMLAudioElement\n   * @param {HTMLAudioElement} audioElement\n   * @param {AudioBuffer|null} [audioBuffer] If provided, will cache all frequency domain data from the buffer\n   * @returns {AudioAnalysis}\n   */\n  constructor(audioElement, audioBuffer = null) {\n    this.fftResults = [];\n    if (audioBuffer) {\n      /**\n       * Modified from\n       * https://stackoverflow.com/questions/75063715/using-the-web-audio-api-to-analyze-a-song-without-playing\n       *\n       * We do this to populate FFT values for the audio if provided an `audioBuffer`\n       * The reason to do this is that Safari fails when using `createMediaElementSource`\n       * This has a non-zero RAM cost so we only opt-in to run it on Safari, Chrome is better\n       */\n      const { length, sampleRate } = audioBuffer;\n      const offlineAudioContext = new OfflineAudioContext({\n        length,\n        sampleRate,\n      });\n      const source = offlineAudioContext.createBufferSource();\n      source.buffer = audioBuffer;\n      const analyser = offlineAudioContext.createAnalyser();\n      analyser.fftSize = 8192;\n      analyser.smoothingTimeConstant = 0.1;\n      source.connect(analyser);\n      // limit is :: 128 / sampleRate;\n      // but we just want 60fps - cuts ~1s from 6MB to 1MB of RAM\n      const renderQuantumInSeconds = 1 / 60;\n      const durationInSeconds = length / sampleRate;\n      const analyze = (index) => {\n        const suspendTime = renderQuantumInSeconds * index;\n        if (suspendTime < durationInSeconds) {\n          offlineAudioContext.suspend(suspendTime).then(() => {\n            const fftResult = new Float32Array(analyser.frequencyBinCount);\n            analyser.getFloatFrequencyData(fftResult);\n            this.fftResults.push(fftResult);\n            analyze(index + 1);\n          });\n        }\n        if (index === 1) {\n          offlineAudioContext.startRendering();\n        } else {\n          offlineAudioContext.resume();\n        }\n      };\n      source.start(0);\n      analyze(1);\n      this.audio = audioElement;\n      this.context = offlineAudioContext;\n      this.analyser = analyser;\n      this.sampleRate = sampleRate;\n      this.audioBuffer = audioBuffer;\n    } else {\n      const audioContext = new AudioContext();\n      const track = audioContext.createMediaElementSource(audioElement);\n      const analyser = audioContext.createAnalyser();\n      analyser.fftSize = 8192;\n      analyser.smoothingTimeConstant = 0.1;\n      track.connect(analyser);\n      analyser.connect(audioContext.destination);\n      this.audio = audioElement;\n      this.context = audioContext;\n      this.analyser = analyser;\n      this.sampleRate = this.context.sampleRate;\n      this.audioBuffer = null;\n    }\n  }\n\n  /**\n   * Gets the current frequency domain data from the playing audio track\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {AudioAnalysisOutputType}\n   */\n  getFrequencies(\n    analysisType = 'frequency',\n    minDecibels = -100,\n    maxDecibels = -30,\n  ) {\n    let fftResult = null;\n    if (this.audioBuffer && this.fftResults.length) {\n      const pct = this.audio.currentTime / this.audio.duration;\n      const index = Math.min(\n        (pct * this.fftResults.length) | 0,\n        this.fftResults.length - 1,\n      );\n      fftResult = this.fftResults[index];\n    }\n    return AudioAnalysis.getFrequencies(\n      this.analyser,\n      this.sampleRate,\n      fftResult,\n      analysisType,\n      minDecibels,\n      maxDecibels,\n    );\n  }\n\n  /**\n   * Resume the internal AudioContext if it was suspended due to the lack of\n   * user interaction when the AudioAnalysis was instantiated.\n   * @returns {Promise<true>}\n   */\n  async resumeIfSuspended() {\n    if (this.context.state === 'suspended') {\n      await this.context.resume();\n    }\n    return true;\n  }\n}\n\nglobalThis.AudioAnalysis = AudioAnalysis;\n","/**\n * Constants for help with visualization\n * Helps map frequency ranges from Fast Fourier Transform\n * to human-interpretable ranges, notably music ranges and\n * human vocal ranges.\n */\n\n// Eighth octave frequencies\nconst octave8Frequencies = [\n  4186.01, 4434.92, 4698.63, 4978.03, 5274.04, 5587.65, 5919.91, 6271.93,\n  6644.88, 7040.0, 7458.62, 7902.13,\n];\n\n// Labels for each of the above frequencies\nconst octave8FrequencyLabels = [\n  'C',\n  'C#',\n  'D',\n  'D#',\n  'E',\n  'F',\n  'F#',\n  'G',\n  'G#',\n  'A',\n  'A#',\n  'B',\n];\n\n/**\n * All note frequencies from 1st to 8th octave\n * in format \"A#8\" (A#, 8th octave)\n */\nexport const noteFrequencies = [];\nexport const noteFrequencyLabels = [];\nfor (let i = 1; i <= 8; i++) {\n  for (let f = 0; f < octave8Frequencies.length; f++) {\n    const freq = octave8Frequencies[f];\n    noteFrequencies.push(freq / Math.pow(2, 8 - i));\n    noteFrequencyLabels.push(octave8FrequencyLabels[f] + i);\n  }\n}\n\n/**\n * Subset of the note frequencies between 32 and 2000 Hz\n * 6 octave range: C1 to B6\n */\nconst voiceFrequencyRange = [32.0, 2000.0];\nexport const voiceFrequencies = noteFrequencies.filter((_, i) => {\n  return (\n    noteFrequencies[i] > voiceFrequencyRange[0] &&\n    noteFrequencies[i] < voiceFrequencyRange[1]\n  );\n});\nexport const voiceFrequencyLabels = noteFrequencyLabels.filter((_, i) => {\n  return (\n    noteFrequencies[i] > voiceFrequencyRange[0] &&\n    noteFrequencies[i] < voiceFrequencyRange[1]\n  );\n});\n","import { StreamProcessorSrc } from \"./worklets/stream_processor.js\";\nimport { AudioAnalysis } from \"./analysis/audio_analysis.js\";\n\n/**\n * Plays audio streams received in raw PCM16 chunks from the browser\n * @class\n */\nexport class WavStreamPlayer {\n  /**\n   * Creates a new WavStreamPlayer instance\n   * @param {{sampleRate?: number}} options\n   * @returns {WavStreamPlayer}\n   */\n  constructor({ sampleRate = 44100 } = {}) {\n    this.scriptSrc = StreamProcessorSrc;\n    this.sampleRate = sampleRate;\n    this.context = null;\n    this.stream = null;\n    this.analyser = null;\n    this.trackSampleOffsets = {};\n    this.interruptedTrackIds = {};\n  }\n\n  /**\n   * Connects the audio context and enables output to speakers\n   * @returns {Promise<true>}\n   */\n  async connect() {\n    this.context = new AudioContext({ sampleRate: this.sampleRate });\n    if (this._speakerID) {\n      this.context.setSinkId(this._speakerID);\n    }\n    if (this.context.state === \"suspended\") {\n      await this.context.resume();\n    }\n    try {\n      await this.context.audioWorklet.addModule(this.scriptSrc);\n    } catch (e) {\n      console.error(e);\n      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);\n    }\n    const analyser = this.context.createAnalyser();\n    analyser.fftSize = 8192;\n    analyser.smoothingTimeConstant = 0.1;\n    this.analyser = analyser;\n    return true;\n  }\n\n  /**\n   * Gets the current frequency domain data from the playing track\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}\n   */\n  getFrequencies(\n    analysisType = \"frequency\",\n    minDecibels = -100,\n    maxDecibels = -30\n  ) {\n    if (!this.analyser) {\n      throw new Error(\"Not connected, please call .connect() first\");\n    }\n    return AudioAnalysis.getFrequencies(\n      this.analyser,\n      this.sampleRate,\n      null,\n      analysisType,\n      minDecibels,\n      maxDecibels\n    );\n  }\n\n  /**\n   * @param {string} speaker deviceId\n   */\n  async updateSpeaker(speaker) {\n    const _prevSpeaker = this._speakerID;\n    this._speakerID = speaker;\n    if (this.context) {\n      try {\n        if (speaker === \"default\") {\n          await this.context.setSinkId();\n        } else {\n          await this.context.setSinkId(speaker);\n        }\n      } catch (e) {\n        console.error(`Could not set sinkId to ${speaker}: ${e}`);\n        this._speakerID = _prevSpeaker;\n      }\n    }\n  }\n\n  /**\n   * Starts audio streaming\n   * @private\n   * @returns {Promise<true>}\n   */\n  _start() {\n    const streamNode = new AudioWorkletNode(this.context, \"stream_processor\");\n    streamNode.connect(this.context.destination);\n    streamNode.port.onmessage = (e) => {\n      const { event } = e.data;\n      if (event === \"stop\") {\n        streamNode.disconnect();\n        this.stream = null;\n      } else if (event === \"offset\") {\n        const { requestId, trackId, offset } = e.data;\n        const currentTime = offset / this.sampleRate;\n        this.trackSampleOffsets[requestId] = { trackId, offset, currentTime };\n      }\n    };\n    this.analyser.disconnect();\n    streamNode.connect(this.analyser);\n    this.stream = streamNode;\n    return true;\n  }\n\n  /**\n   * Adds 16BitPCM data to the currently playing audio stream\n   * You can add chunks beyond the current play point and they will be queued for play\n   * @param {ArrayBuffer|Int16Array} arrayBuffer\n   * @param {string} [trackId]\n   * @returns {Int16Array}\n   */\n  add16BitPCM(arrayBuffer, trackId = \"default\") {\n    if (typeof trackId !== \"string\") {\n      throw new Error(`trackId must be a string`);\n    } else if (this.interruptedTrackIds[trackId]) {\n      return;\n    }\n    if (!this.stream) {\n      this._start();\n    }\n    let buffer;\n    if (arrayBuffer instanceof Int16Array) {\n      buffer = arrayBuffer;\n    } else if (arrayBuffer instanceof ArrayBuffer) {\n      buffer = new Int16Array(arrayBuffer);\n    } else {\n      throw new Error(`argument must be Int16Array or ArrayBuffer`);\n    }\n    this.stream.port.postMessage({ event: \"write\", buffer, trackId });\n    return buffer;\n  }\n\n  /**\n   * Gets the offset (sample count) of the currently playing stream\n   * @param {boolean} [interrupt]\n   * @returns {{trackId: string|null, offset: number, currentTime: number}}\n   */\n  async getTrackSampleOffset(interrupt = false) {\n    if (!this.stream) {\n      return null;\n    }\n    const requestId = crypto.randomUUID();\n    this.stream.port.postMessage({\n      event: interrupt ? \"interrupt\" : \"offset\",\n      requestId,\n    });\n    let trackSampleOffset;\n    while (!trackSampleOffset) {\n      trackSampleOffset = this.trackSampleOffsets[requestId];\n      await new Promise((r) => setTimeout(() => r(), 1));\n    }\n    const { trackId } = trackSampleOffset;\n    if (interrupt && trackId) {\n      this.interruptedTrackIds[trackId] = true;\n    }\n    return trackSampleOffset;\n  }\n\n  /**\n   * Strips the current stream and returns the sample offset of the audio\n   * @param {boolean} [interrupt]\n   * @returns {{trackId: string|null, offset: number, currentTime: number}}\n   */\n  async interrupt() {\n    return this.getTrackSampleOffset(true);\n  }\n}\n\nglobalThis.WavStreamPlayer = WavStreamPlayer;\n","export const StreamProcessorWorklet = `\nclass StreamProcessor extends AudioWorkletProcessor {\n  constructor() {\n    super();\n    this.hasStarted = false;\n    this.hasInterrupted = false;\n    this.outputBuffers = [];\n    this.bufferLength = 128;\n    this.write = { buffer: new Float32Array(this.bufferLength), trackId: null };\n    this.writeOffset = 0;\n    this.trackSampleOffsets = {};\n    this.port.onmessage = (event) => {\n      if (event.data) {\n        const payload = event.data;\n        if (payload.event === 'write') {\n          const int16Array = payload.buffer;\n          const float32Array = new Float32Array(int16Array.length);\n          for (let i = 0; i < int16Array.length; i++) {\n            float32Array[i] = int16Array[i] / 0x8000; // Convert Int16 to Float32\n          }\n          this.writeData(float32Array, payload.trackId);\n        } else if (\n          payload.event === 'offset' ||\n          payload.event === 'interrupt'\n        ) {\n          const requestId = payload.requestId;\n          const trackId = this.write.trackId;\n          const offset = this.trackSampleOffsets[trackId] || 0;\n          this.port.postMessage({\n            event: 'offset',\n            requestId,\n            trackId,\n            offset,\n          });\n          if (payload.event === 'interrupt') {\n            this.hasInterrupted = true;\n          }\n        } else {\n          throw new Error(\\`Unhandled event \"\\${payload.event}\"\\`);\n        }\n      }\n    };\n  }\n\n  writeData(float32Array, trackId = null) {\n    let { buffer } = this.write;\n    let offset = this.writeOffset;\n    for (let i = 0; i < float32Array.length; i++) {\n      buffer[offset++] = float32Array[i];\n      if (offset >= buffer.length) {\n        this.outputBuffers.push(this.write);\n        this.write = { buffer: new Float32Array(this.bufferLength), trackId };\n        buffer = this.write.buffer;\n        offset = 0;\n      }\n    }\n    this.writeOffset = offset;\n    return true;\n  }\n\n  process(inputs, outputs, parameters) {\n    const output = outputs[0];\n    const outputChannelData = output[0];\n    const outputBuffers = this.outputBuffers;\n    if (this.hasInterrupted) {\n      this.port.postMessage({ event: 'stop' });\n      return false;\n    } else if (outputBuffers.length) {\n      this.hasStarted = true;\n      const { buffer, trackId } = outputBuffers.shift();\n      for (let i = 0; i < outputChannelData.length; i++) {\n        outputChannelData[i] = buffer[i] || 0;\n      }\n      if (trackId) {\n        this.trackSampleOffsets[trackId] =\n          this.trackSampleOffsets[trackId] || 0;\n        this.trackSampleOffsets[trackId] += buffer.length;\n      }\n      return true;\n    } else if (this.hasStarted) {\n      this.port.postMessage({ event: 'stop' });\n      return false;\n    } else {\n      return true;\n    }\n  }\n}\n\nregisterProcessor('stream_processor', StreamProcessor);\n`;\n\nconst script = new Blob([StreamProcessorWorklet], {\n  type: 'application/javascript',\n});\nconst src = URL.createObjectURL(script);\nexport const StreamProcessorSrc = src;\n","import { AudioProcessorSrc } from './worklets/audio_processor.js';\nimport { AudioAnalysis } from './analysis/audio_analysis.js';\nimport { WavPacker } from './wav_packer.js';\n\n/**\n * Decodes audio into a wav file\n * @typedef {Object} DecodedAudioType\n * @property {Blob} blob\n * @property {string} url\n * @property {Float32Array} values\n * @property {AudioBuffer} audioBuffer\n */\n\n/**\n * Records live stream of user audio as PCM16 \"audio/wav\" data\n * @class\n */\nexport class WavRecorder {\n  /**\n   * Create a new WavRecorder instance\n   * @param {{sampleRate?: number, outputToSpeakers?: boolean, debug?: boolean}} [options]\n   * @returns {WavRecorder}\n   */\n  constructor({\n    sampleRate = 44100,\n    outputToSpeakers = false,\n    debug = false,\n  } = {}) {\n    // Script source\n    this.scriptSrc = AudioProcessorSrc;\n    // Config\n    this.sampleRate = sampleRate;\n    this.outputToSpeakers = outputToSpeakers;\n    this.debug = !!debug;\n    this._deviceChangeCallback = null;\n    this._deviceErrorCallback = null;\n    this._devices = [];\n    this.deviceSelection = null;\n    // State variables\n    this.stream = null;\n    this.processor = null;\n    this.source = null;\n    this.node = null;\n    this.recording = false;\n    // Event handling with AudioWorklet\n    this._lastEventId = 0;\n    this.eventReceipts = {};\n    this.eventTimeout = 5000;\n    // Process chunks of audio\n    this._chunkProcessor = () => {};\n    this._chunkProcessorSize = void 0;\n    this._chunkProcessorBuffer = {\n      raw: new ArrayBuffer(0),\n      mono: new ArrayBuffer(0),\n    };\n  }\n\n  /**\n   * Decodes audio data from multiple formats to a Blob, url, Float32Array and AudioBuffer\n   * @param {Blob|Float32Array|Int16Array|ArrayBuffer|number[]} audioData\n   * @param {number} sampleRate\n   * @param {number} fromSampleRate\n   * @returns {Promise<DecodedAudioType>}\n   */\n  static async decode(audioData, sampleRate = 44100, fromSampleRate = -1) {\n    const context = new AudioContext({ sampleRate });\n    let arrayBuffer;\n    let blob;\n    if (audioData instanceof Blob) {\n      if (fromSampleRate !== -1) {\n        throw new Error(\n          `Can not specify \"fromSampleRate\" when reading from Blob`\n        );\n      }\n      blob = audioData;\n      arrayBuffer = await blob.arrayBuffer();\n    } else if (audioData instanceof ArrayBuffer) {\n      if (fromSampleRate !== -1) {\n        throw new Error(\n          `Can not specify \"fromSampleRate\" when reading from ArrayBuffer`\n        );\n      }\n      arrayBuffer = audioData;\n      blob = new Blob([arrayBuffer], { type: 'audio/wav' });\n    } else {\n      let float32Array;\n      let data;\n      if (audioData instanceof Int16Array) {\n        data = audioData;\n        float32Array = new Float32Array(audioData.length);\n        for (let i = 0; i < audioData.length; i++) {\n          float32Array[i] = audioData[i] / 0x8000;\n        }\n      } else if (audioData instanceof Float32Array) {\n        float32Array = audioData;\n      } else if (audioData instanceof Array) {\n        float32Array = new Float32Array(audioData);\n      } else {\n        throw new Error(\n          `\"audioData\" must be one of: Blob, Float32Arrray, Int16Array, ArrayBuffer, Array<number>`\n        );\n      }\n      if (fromSampleRate === -1) {\n        throw new Error(\n          `Must specify \"fromSampleRate\" when reading from Float32Array, In16Array or Array`\n        );\n      } else if (fromSampleRate < 3000) {\n        throw new Error(`Minimum \"fromSampleRate\" is 3000 (3kHz)`);\n      }\n      if (!data) {\n        data = WavPacker.floatTo16BitPCM(float32Array);\n      }\n      const audio = {\n        bitsPerSample: 16,\n        channels: [float32Array],\n        data,\n      };\n      const packer = new WavPacker();\n      const result = packer.pack(fromSampleRate, audio);\n      blob = result.blob;\n      arrayBuffer = await blob.arrayBuffer();\n    }\n    const audioBuffer = await context.decodeAudioData(arrayBuffer);\n    const values = audioBuffer.getChannelData(0);\n    const url = URL.createObjectURL(blob);\n    return {\n      blob,\n      url,\n      values,\n      audioBuffer,\n    };\n  }\n\n  /**\n   * Logs data in debug mode\n   * @param {...any} arguments\n   * @returns {true}\n   */\n  log() {\n    if (this.debug) {\n      this.log(...arguments);\n    }\n    return true;\n  }\n\n  /**\n   * Retrieves the current sampleRate for the recorder\n   * @returns {number}\n   */\n  getSampleRate() {\n    return this.sampleRate;\n  }\n\n  /**\n   * Retrieves the current status of the recording\n   * @returns {\"ended\"|\"paused\"|\"recording\"}\n   */\n  getStatus() {\n    if (!this.processor) {\n      return 'ended';\n    } else if (!this.recording) {\n      return 'paused';\n    } else {\n      return 'recording';\n    }\n  }\n\n  /**\n   * Sends an event to the AudioWorklet\n   * @private\n   * @param {string} name\n   * @param {{[key: string]: any}} data\n   * @param {AudioWorkletNode} [_processor]\n   * @returns {Promise<{[key: string]: any}>}\n   */\n  async _event(name, data = {}, _processor = null) {\n    _processor = _processor || this.processor;\n    if (!_processor) {\n      throw new Error('Can not send events without recording first');\n    }\n    const message = {\n      event: name,\n      id: this._lastEventId++,\n      data,\n    };\n    _processor.port.postMessage(message);\n    const t0 = new Date().valueOf();\n    while (!this.eventReceipts[message.id]) {\n      if (new Date().valueOf() - t0 > this.eventTimeout) {\n        throw new Error(`Timeout waiting for \"${name}\" event`);\n      }\n      await new Promise((res) => setTimeout(() => res(true), 1));\n    }\n    const payload = this.eventReceipts[message.id];\n    delete this.eventReceipts[message.id];\n    return payload;\n  }\n\n  /**\n   * Sets device change callback, remove if callback provided is `null`\n   * @param {(Array<MediaDeviceInfo & {default: boolean}>): void|null} callback\n   * @returns {true}\n   */\n  listenForDeviceChange(callback) {\n    if (callback === null && this._deviceChangeCallback) {\n      navigator.mediaDevices.removeEventListener(\n        'devicechange',\n        this._deviceChangeCallback\n      );\n      this._deviceChangeCallback = null;\n    } else if (callback !== null) {\n      // Basically a debounce; we only want this called once when devices change\n      // And we only want the most recent callback() to be executed\n      // if a few are operating at the same time\n      let lastId = 0;\n      let lastDevices = [];\n      const serializeDevices = (devices) =>\n        devices\n          .map((d) => d.deviceId)\n          .sort()\n          .join(',');\n      const cb = async () => {\n        let id = ++lastId;\n        const devices = await this.listDevices();\n        if (id === lastId) {\n          if (serializeDevices(lastDevices) !== serializeDevices(devices)) {\n            lastDevices = devices;\n            callback(devices.slice());\n          }\n        }\n      };\n      navigator.mediaDevices.addEventListener('devicechange', cb);\n      cb();\n      this._deviceChangeCallback = cb;\n    }\n    return true;\n  }\n\n  /**\n   * Provide a callback for if/when device errors occur\n   * @param {(({devices: Array<\"cam\" | \"mic\">, type: string, error?: Error}) => void) | null} callback\n   * @returns {true}\n   */\n  listenForDeviceErrors(callback) {\n    this._deviceErrorCallback = callback;\n  }\n\n  /**\n   * Manually request permission to use the microphone\n   * @returns {Promise<true>}\n   */\n  async requestPermission() {\n    const permissionStatus = await navigator.permissions.query({\n      name: 'microphone',\n    });\n    if (permissionStatus.state === 'denied') {\n      if (this._deviceErrorCallback) {\n        this._deviceErrorCallback({\n          devices: [\"mic\"],\n          type: \"unknown\",\n          error: new Error(\"Microphone access denied\"),\n        });\n      }\n    } else if (permissionStatus.state === 'prompt') {\n      try {\n        const stream = await navigator.mediaDevices.getUserMedia({\n          audio: true,\n        });\n        const tracks = stream.getTracks();\n        tracks.forEach((track) => track.stop());\n      } catch (e) {\n        console.error(\"Error accessing microphone.\");\n        if (this._deviceErrorCallback) {\n          this._deviceErrorCallback({\n            devices: [\"mic\"],\n            type: \"unknown\",\n            error: e,\n          });\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * List all eligible devices for recording, will request permission to use microphone\n   * @returns {Promise<Array<MediaDeviceInfo & {default: boolean}>>}\n   */\n  async listDevices() {\n    if (\n      !navigator.mediaDevices ||\n      !('enumerateDevices' in navigator.mediaDevices)\n    ) {\n      throw new Error('Could not request user devices');\n    }\n    await this.requestPermission();\n    const devices = await navigator.mediaDevices.enumerateDevices();\n    const audioDevices = devices.filter(\n      (device) => device.kind === 'audioinput'\n    );\n    return audioDevices;\n    // const defaultDeviceIndex = audioDevices.findIndex(\n    //   (device) => device.deviceId === 'default'\n    // );\n    // const deviceList = [];\n    // if (defaultDeviceIndex !== -1) {\n    //   let defaultDevice = audioDevices.splice(defaultDeviceIndex, 1)[0];\n    //   let existingIndex = audioDevices.findIndex(\n    //     (device) => device.groupId === defaultDevice.groupId\n    //   );\n    //   if (existingIndex !== -1) {\n    //     defaultDevice = audioDevices.splice(existingIndex, 1)[0];\n    //   }\n    //   defaultDevice.default = true;\n    //   deviceList.push(defaultDevice);\n    // }\n    // return deviceList.concat(audioDevices);\n  }\n\n  /**\n   * Begins a recording session and requests microphone permissions if not already granted\n   * Microphone recording indicator will appear on browser tab but status will be \"paused\"\n   * @param {string} [deviceId] if no device provided, default device will be used\n   * @returns {Promise<true>}\n   */\n  async begin(deviceId) {\n    if (this.processor) {\n      throw new Error(\n        `Already connected: please call .end() to start a new session`\n      );\n    }\n\n    if (\n      !navigator.mediaDevices ||\n      !('getUserMedia' in navigator.mediaDevices)\n    ) {\n      if (this._deviceErrorCallback) {\n        this._deviceErrorCallback({\n          devices: [\"mic\", \"cam\"],\n          type: \"undefined-mediadevices\",\n        });\n      }\n      throw new Error('Could not request user media');\n    }\n    deviceId = deviceId ?? this.deviceSelection?.deviceId;\n    try {\n      const config = { audio: true };\n      if (deviceId) {\n        config.audio = { deviceId: { exact: deviceId } };\n      }\n      this.stream = await navigator.mediaDevices.getUserMedia(config);\n    } catch (err) {\n      if (this._deviceErrorCallback) {\n        this._deviceErrorCallback({\n          devices: [\"mic\"],\n          type: \"unknown\",\n          error: err,\n        });\n      }\n      throw new Error('Could not start media stream');\n    }\n\n    this.listDevices().then((devices) => {\n      deviceId = this.stream.getAudioTracks()[0].getSettings().deviceId;\n      console.log(\n        'find current device',\n        devices,\n        deviceId,\n        this.stream.getAudioTracks()[0].getSettings()\n      );\n      this.deviceSelection = devices.find((d) => d.deviceId === deviceId);\n      console.log('current device', this.deviceSelection);\n    });\n    const context = new AudioContext({ sampleRate: this.sampleRate });\n    const source = context.createMediaStreamSource(this.stream);\n    // Load and execute the module script.\n    try {\n      await context.audioWorklet.addModule(this.scriptSrc);\n    } catch (e) {\n      console.error(e);\n      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);\n    }\n    const processor = new AudioWorkletNode(context, 'audio_processor');\n    processor.port.onmessage = (e) => {\n      const { event, id, data } = e.data;\n      if (event === 'receipt') {\n        this.eventReceipts[id] = data;\n      } else if (event === 'chunk') {\n        if (this._chunkProcessorSize) {\n          const buffer = this._chunkProcessorBuffer;\n          this._chunkProcessorBuffer = {\n            raw: WavPacker.mergeBuffers(buffer.raw, data.raw),\n            mono: WavPacker.mergeBuffers(buffer.mono, data.mono),\n          };\n          if (\n            this._chunkProcessorBuffer.mono.byteLength >=\n            this._chunkProcessorSize\n          ) {\n            this._chunkProcessor(this._chunkProcessorBuffer);\n            this._chunkProcessorBuffer = {\n              raw: new ArrayBuffer(0),\n              mono: new ArrayBuffer(0),\n            };\n          }\n        } else {\n          this._chunkProcessor(data);\n        }\n      }\n    };\n\n    const node = source.connect(processor);\n    const analyser = context.createAnalyser();\n    analyser.fftSize = 8192;\n    analyser.smoothingTimeConstant = 0.1;\n    node.connect(analyser);\n    if (this.outputToSpeakers) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        'Warning: Output to speakers may affect sound quality,\\n' +\n          'especially due to system audio feedback preventative measures.\\n' +\n          'use only for debugging'\n      );\n      analyser.connect(context.destination);\n    }\n\n    this.source = source;\n    this.node = node;\n    this.analyser = analyser;\n    this.processor = processor;\n    console.log('begin completed');\n    return true;\n  }\n\n  /**\n   * Gets the current frequency domain data from the recording track\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}\n   */\n  getFrequencies(\n    analysisType = 'frequency',\n    minDecibels = -100,\n    maxDecibels = -30\n  ) {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    return AudioAnalysis.getFrequencies(\n      this.analyser,\n      this.sampleRate,\n      null,\n      analysisType,\n      minDecibels,\n      maxDecibels\n    );\n  }\n\n  /**\n   * Pauses the recording\n   * Keeps microphone stream open but halts storage of audio\n   * @returns {Promise<true>}\n   */\n  async pause() {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    } else if (!this.recording) {\n      throw new Error('Already paused: please call .record() first');\n    }\n    if (this._chunkProcessorBuffer.raw.byteLength) {\n      this._chunkProcessor(this._chunkProcessorBuffer);\n    }\n    this.log('Pausing ...');\n    await this._event('stop');\n    this.recording = false;\n    return true;\n  }\n\n  /**\n   * Start recording stream and storing to memory from the connected audio source\n   * @param {(data: { mono: Int16Array; raw: Int16Array }) => any} [chunkProcessor]\n   * @param {number} [chunkSize] chunkProcessor will not be triggered until this size threshold met in mono audio\n   * @returns {Promise<true>}\n   */\n  async record(chunkProcessor = () => {}, chunkSize = 8192) {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    } else if (this.recording) {\n      throw new Error('Already recording: please call .pause() first');\n    } else if (typeof chunkProcessor !== 'function') {\n      throw new Error(`chunkProcessor must be a function`);\n    }\n    this._chunkProcessor = chunkProcessor;\n    this._chunkProcessorSize = chunkSize;\n    this._chunkProcessorBuffer = {\n      raw: new ArrayBuffer(0),\n      mono: new ArrayBuffer(0),\n    };\n    this.log('Recording ...');\n    await this._event('start');\n    this.recording = true;\n    return true;\n  }\n\n  /**\n   * Clears the audio buffer, empties stored recording\n   * @returns {Promise<true>}\n   */\n  async clear() {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    await this._event('clear');\n    return true;\n  }\n\n  /**\n   * Reads the current audio stream data\n   * @returns {Promise<{meanValues: Float32Array, channels: Array<Float32Array>}>}\n   */\n  async read() {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    this.log('Reading ...');\n    const result = await this._event('read');\n    return result;\n  }\n\n  /**\n   * Saves the current audio stream to a file\n   * @param {boolean} [force] Force saving while still recording\n   * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}\n   */\n  async save(force = false) {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n    if (!force && this.recording) {\n      throw new Error(\n        'Currently recording: please call .pause() first, or call .save(true) to force'\n      );\n    }\n    this.log('Exporting ...');\n    const exportData = await this._event('export');\n    const packer = new WavPacker();\n    const result = packer.pack(this.sampleRate, exportData.audio);\n    return result;\n  }\n\n  /**\n   * Ends the current recording session and saves the result\n   * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}\n   */\n  async end() {\n    if (!this.processor) {\n      throw new Error('Session ended: please call .begin() first');\n    }\n\n    const _processor = this.processor;\n\n    this.log('Stopping ...');\n    await this._event('stop');\n    this.recording = false;\n    const tracks = this.stream.getTracks();\n    tracks.forEach((track) => track.stop());\n\n    this.log('Exporting ...');\n    const exportData = await this._event('export', {}, _processor);\n\n    this.processor.disconnect();\n    this.source.disconnect();\n    this.node.disconnect();\n    this.analyser.disconnect();\n    this.stream = null;\n    this.processor = null;\n    this.source = null;\n    this.node = null;\n\n    const packer = new WavPacker();\n    const result = packer.pack(this.sampleRate, exportData.audio);\n    return result;\n  }\n\n  /**\n   * Performs a full cleanup of WavRecorder instance\n   * Stops actively listening via microphone and removes existing listeners\n   * @returns {Promise<true>}\n   */\n  async quit() {\n    this.listenForDeviceChange(null);\n    // we do not reset this on end so that selections persist across starts\n    this.deviceSelection = null;\n    if (this.processor) {\n      await this.end();\n    }\n    return true;\n  }\n}\n\nglobalThis.WavRecorder = WavRecorder;\n","const AudioProcessorWorklet = `\nclass AudioProcessor extends AudioWorkletProcessor {\n\n  constructor() {\n    super();\n    this.port.onmessage = this.receive.bind(this);\n    this.initialize();\n  }\n\n  initialize() {\n    this.foundAudio = false;\n    this.recording = false;\n    this.chunks = [];\n  }\n\n  /**\n   * Concatenates sampled chunks into channels\n   * Format is chunk[Left[], Right[]]\n   */\n  readChannelData(chunks, channel = -1, maxChannels = 9) {\n    let channelLimit;\n    if (channel !== -1) {\n      if (chunks[0] && chunks[0].length - 1 < channel) {\n        throw new Error(\n          \\`Channel \\${channel} out of range: max \\${chunks[0].length}\\`\n        );\n      }\n      channelLimit = channel + 1;\n    } else {\n      channel = 0;\n      channelLimit = Math.min(chunks[0] ? chunks[0].length : 1, maxChannels);\n    }\n    const channels = [];\n    for (let n = channel; n < channelLimit; n++) {\n      const length = chunks.reduce((sum, chunk) => {\n        return sum + chunk[n].length;\n      }, 0);\n      const buffers = chunks.map((chunk) => chunk[n]);\n      const result = new Float32Array(length);\n      let offset = 0;\n      for (let i = 0; i < buffers.length; i++) {\n        result.set(buffers[i], offset);\n        offset += buffers[i].length;\n      }\n      channels[n] = result;\n    }\n    return channels;\n  }\n\n  /**\n   * Combines parallel audio data into correct format,\n   * channels[Left[], Right[]] to float32Array[LRLRLRLR...]\n   */\n  formatAudioData(channels) {\n    if (channels.length === 1) {\n      // Simple case is only one channel\n      const float32Array = channels[0].slice();\n      const meanValues = channels[0].slice();\n      return { float32Array, meanValues };\n    } else {\n      const float32Array = new Float32Array(\n        channels[0].length * channels.length\n      );\n      const meanValues = new Float32Array(channels[0].length);\n      for (let i = 0; i < channels[0].length; i++) {\n        const offset = i * channels.length;\n        let meanValue = 0;\n        for (let n = 0; n < channels.length; n++) {\n          float32Array[offset + n] = channels[n][i];\n          meanValue += channels[n][i];\n        }\n        meanValues[i] = meanValue / channels.length;\n      }\n      return { float32Array, meanValues };\n    }\n  }\n\n  /**\n   * Converts 32-bit float data to 16-bit integers\n   */\n  floatTo16BitPCM(float32Array) {\n    const buffer = new ArrayBuffer(float32Array.length * 2);\n    const view = new DataView(buffer);\n    let offset = 0;\n    for (let i = 0; i < float32Array.length; i++, offset += 2) {\n      let s = Math.max(-1, Math.min(1, float32Array[i]));\n      view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7fff, true);\n    }\n    return buffer;\n  }\n\n  /**\n   * Retrieves the most recent amplitude values from the audio stream\n   * @param {number} channel\n   */\n  getValues(channel = -1) {\n    const channels = this.readChannelData(this.chunks, channel);\n    const { meanValues } = this.formatAudioData(channels);\n    return { meanValues, channels };\n  }\n\n  /**\n   * Exports chunks as an audio/wav file\n   */\n  export() {\n    const channels = this.readChannelData(this.chunks);\n    const { float32Array, meanValues } = this.formatAudioData(channels);\n    const audioData = this.floatTo16BitPCM(float32Array);\n    return {\n      meanValues: meanValues,\n      audio: {\n        bitsPerSample: 16,\n        channels: channels,\n        data: audioData,\n      },\n    };\n  }\n\n  receive(e) {\n    const { event, id } = e.data;\n    let receiptData = {};\n    switch (event) {\n      case 'start':\n        this.recording = true;\n        break;\n      case 'stop':\n        this.recording = false;\n        break;\n      case 'clear':\n        this.initialize();\n        break;\n      case 'export':\n        receiptData = this.export();\n        break;\n      case 'read':\n        receiptData = this.getValues();\n        break;\n      default:\n        break;\n    }\n    // Always send back receipt\n    this.port.postMessage({ event: 'receipt', id, data: receiptData });\n  }\n\n  sendChunk(chunk) {\n    const channels = this.readChannelData([chunk]);\n    const { float32Array, meanValues } = this.formatAudioData(channels);\n    const rawAudioData = this.floatTo16BitPCM(float32Array);\n    const monoAudioData = this.floatTo16BitPCM(meanValues);\n    this.port.postMessage({\n      event: 'chunk',\n      data: {\n        mono: monoAudioData,\n        raw: rawAudioData,\n      },\n    });\n  }\n\n  process(inputList, outputList, parameters) {\n    // Copy input to output (e.g. speakers)\n    // Note that this creates choppy sounds with Mac products\n    const sourceLimit = Math.min(inputList.length, outputList.length);\n    for (let inputNum = 0; inputNum < sourceLimit; inputNum++) {\n      const input = inputList[inputNum];\n      const output = outputList[inputNum];\n      const channelCount = Math.min(input.length, output.length);\n      for (let channelNum = 0; channelNum < channelCount; channelNum++) {\n        input[channelNum].forEach((sample, i) => {\n          output[channelNum][i] = sample;\n        });\n      }\n    }\n    const inputs = inputList[0];\n    // There's latency at the beginning of a stream before recording starts\n    // Make sure we actually receive audio data before we start storing chunks\n    let sliceIndex = 0;\n    if (!this.foundAudio) {\n      for (const channel of inputs) {\n        sliceIndex = 0; // reset for each channel\n        if (this.foundAudio) {\n          break;\n        }\n        if (channel) {\n          for (const value of channel) {\n            if (value !== 0) {\n              // find only one non-zero entry in any channel\n              this.foundAudio = true;\n              break;\n            } else {\n              sliceIndex++;\n            }\n          }\n        }\n      }\n    }\n    if (inputs && inputs[0] && this.foundAudio && this.recording) {\n      // We need to copy the TypedArray, because the \\`process\\`\n      // internals will reuse the same buffer to hold each input\n      const chunk = inputs.map((input) => input.slice(sliceIndex));\n      this.chunks.push(chunk);\n      this.sendChunk(chunk);\n    }\n    return true;\n  }\n}\n\nregisterProcessor('audio_processor', AudioProcessor);\n`;\n\nconst script = new Blob([AudioProcessorWorklet], {\n  type: 'application/javascript',\n});\nconst src = URL.createObjectURL(script);\nexport const AudioProcessorSrc = src;\n","import { AudioProcessorSrc } from \"./worklets/audio_processor.js\";\nimport { AudioAnalysis } from \"./analysis/audio_analysis.js\";\nimport { WavPacker } from \"./wav_packer.js\";\n\n/**\n * Decodes audio into a wav file\n * @typedef {Object} DecodedAudioType\n * @property {Blob} blob\n * @property {string} url\n * @property {Float32Array} values\n * @property {AudioBuffer} audioBuffer\n */\n\n/**\n * Records live stream of user audio as PCM16 \"audio/wav\" data\n * @class\n */\nexport class MediaStreamRecorder {\n  /**\n   * Create a new MediaStreamRecorder instance\n   * @param {{sampleRate?: number, outputToSpeakers?: boolean, debug?: boolean}} [options]\n   * @returns {MediaStreamRecorder}\n   */\n  constructor({\n    sampleRate = 44100,\n    outputToSpeakers = false,\n    debug = false,\n  } = {}) {\n    // Script source\n    this.scriptSrc = AudioProcessorSrc;\n    // Config\n    this.sampleRate = sampleRate;\n    this.outputToSpeakers = outputToSpeakers;\n    this.debug = !!debug;\n    // State variables\n    this.stream = null;\n    this.processor = null;\n    this.source = null;\n    this.node = null;\n    this.recording = false;\n    // Event handling with AudioWorklet\n    this._lastEventId = 0;\n    this.eventReceipts = {};\n    this.eventTimeout = 5000;\n    // Process chunks of audio\n    this._chunkProcessor = () => {};\n    this._chunkProcessorSize = void 0;\n    this._chunkProcessorBuffer = {\n      raw: new ArrayBuffer(0),\n      mono: new ArrayBuffer(0),\n    };\n  }\n\n  /**\n   * Logs data in debug mode\n   * @param {...any} arguments\n   * @returns {true}\n   */\n  log() {\n    if (this.debug) {\n      this.log(...arguments);\n    }\n    return true;\n  }\n\n  /**\n   * Retrieves the current sampleRate for the recorder\n   * @returns {number}\n   */\n  getSampleRate() {\n    return this.sampleRate;\n  }\n\n  /**\n   * Retrieves the current status of the recording\n   * @returns {\"ended\"|\"paused\"|\"recording\"}\n   */\n  getStatus() {\n    if (!this.processor) {\n      return \"ended\";\n    } else if (!this.recording) {\n      return \"paused\";\n    } else {\n      return \"recording\";\n    }\n  }\n\n  /**\n   * Sends an event to the AudioWorklet\n   * @private\n   * @param {string} name\n   * @param {{[key: string]: any}} data\n   * @param {AudioWorkletNode} [_processor]\n   * @returns {Promise<{[key: string]: any}>}\n   */\n  async _event(name, data = {}, _processor = null) {\n    _processor = _processor || this.processor;\n    if (!_processor) {\n      throw new Error(\"Can not send events without recording first\");\n    }\n    const message = {\n      event: name,\n      id: this._lastEventId++,\n      data,\n    };\n    _processor.port.postMessage(message);\n    const t0 = new Date().valueOf();\n    while (!this.eventReceipts[message.id]) {\n      if (new Date().valueOf() - t0 > this.eventTimeout) {\n        throw new Error(`Timeout waiting for \"${name}\" event`);\n      }\n      await new Promise((res) => setTimeout(() => res(true), 1));\n    }\n    const payload = this.eventReceipts[message.id];\n    delete this.eventReceipts[message.id];\n    return payload;\n  }\n\n  /**\n   * Begins a recording session for the given audioTrack\n   * Microphone recording indicator will appear on browser tab but status will be \"paused\"\n   * @param {MediaStreamTrack} [audioTrack] if no device provided, default device will be used\n   * @returns {Promise<true>}\n   */\n  async begin(audioTrack) {\n    if (this.processor) {\n      throw new Error(\n        `Already connected: please call .end() to start a new session`\n      );\n    }\n\n    if (!audioTrack || audioTrack.kind !== \"audio\") {\n      throw new Error(\"No audio track provided\");\n    }\n\n    this.stream = new MediaStream([audioTrack]);\n\n    const context = new AudioContext({ sampleRate: this.sampleRate });\n    const source = context.createMediaStreamSource(this.stream);\n    // Load and execute the module script.\n    try {\n      await context.audioWorklet.addModule(this.scriptSrc);\n    } catch (e) {\n      console.error(e);\n      throw new Error(`Could not add audioWorklet module: ${this.scriptSrc}`);\n    }\n    const processor = new AudioWorkletNode(context, \"audio_processor\");\n    processor.port.onmessage = (e) => {\n      const { event, id, data } = e.data;\n      if (event === \"receipt\") {\n        this.eventReceipts[id] = data;\n      } else if (event === \"chunk\") {\n        if (this._chunkProcessorSize) {\n          const buffer = this._chunkProcessorBuffer;\n          this._chunkProcessorBuffer = {\n            raw: WavPacker.mergeBuffers(buffer.raw, data.raw),\n            mono: WavPacker.mergeBuffers(buffer.mono, data.mono),\n          };\n          if (\n            this._chunkProcessorBuffer.mono.byteLength >=\n            this._chunkProcessorSize\n          ) {\n            this._chunkProcessor(this._chunkProcessorBuffer);\n            this._chunkProcessorBuffer = {\n              raw: new ArrayBuffer(0),\n              mono: new ArrayBuffer(0),\n            };\n          }\n        } else {\n          this._chunkProcessor(data);\n        }\n      }\n    };\n\n    const node = source.connect(processor);\n    const analyser = context.createAnalyser();\n    analyser.fftSize = 8192;\n    analyser.smoothingTimeConstant = 0.1;\n    node.connect(analyser);\n    if (this.outputToSpeakers) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        \"Warning: Output to speakers may affect sound quality,\\n\" +\n          \"especially due to system audio feedback preventative measures.\\n\" +\n          \"use only for debugging\"\n      );\n      analyser.connect(context.destination);\n    }\n\n    this.source = source;\n    this.node = node;\n    this.analyser = analyser;\n    this.processor = processor;\n    return true;\n  }\n\n  /**\n   * Gets the current frequency domain data from the recording track\n   * @param {\"frequency\"|\"music\"|\"voice\"} [analysisType]\n   * @param {number} [minDecibels] default -100\n   * @param {number} [maxDecibels] default -30\n   * @returns {import('./analysis/audio_analysis.js').AudioAnalysisOutputType}\n   */\n  getFrequencies(\n    analysisType = \"frequency\",\n    minDecibels = -100,\n    maxDecibels = -30\n  ) {\n    if (!this.processor) {\n      throw new Error(\"Session ended: please call .begin() first\");\n    }\n    return AudioAnalysis.getFrequencies(\n      this.analyser,\n      this.sampleRate,\n      null,\n      analysisType,\n      minDecibels,\n      maxDecibels\n    );\n  }\n\n  /**\n   * Pauses the recording\n   * Keeps microphone stream open but halts storage of audio\n   * @returns {Promise<true>}\n   */\n  async pause() {\n    if (!this.processor) {\n      throw new Error(\"Session ended: please call .begin() first\");\n    } else if (!this.recording) {\n      throw new Error(\"Already paused: please call .record() first\");\n    }\n    if (this._chunkProcessorBuffer.raw.byteLength) {\n      this._chunkProcessor(this._chunkProcessorBuffer);\n    }\n    this.log(\"Pausing ...\");\n    await this._event(\"stop\");\n    this.recording = false;\n    return true;\n  }\n\n  /**\n   * Start recording stream and storing to memory from the connected audio source\n   * @param {(data: { mono: Int16Array; raw: Int16Array }) => any} [chunkProcessor]\n   * @param {number} [chunkSize] chunkProcessor will not be triggered until this size threshold met in mono audio\n   * @returns {Promise<true>}\n   */\n  async record(chunkProcessor = () => {}, chunkSize = 8192) {\n    if (!this.processor) {\n      throw new Error(\"Session ended: please call .begin() first\");\n    } else if (this.recording) {\n      throw new Error(\"Already recording: HELLO please call .pause() first\");\n    } else if (typeof chunkProcessor !== \"function\") {\n      throw new Error(`chunkProcessor must be a function`);\n    }\n    this._chunkProcessor = chunkProcessor;\n    this._chunkProcessorSize = chunkSize;\n    this._chunkProcessorBuffer = {\n      raw: new ArrayBuffer(0),\n      mono: new ArrayBuffer(0),\n    };\n    this.log(\"Recording ...\");\n    await this._event(\"start\");\n    this.recording = true;\n    return true;\n  }\n\n  /**\n   * Clears the audio buffer, empties stored recording\n   * @returns {Promise<true>}\n   */\n  async clear() {\n    if (!this.processor) {\n      throw new Error(\"Session ended: please call .begin() first\");\n    }\n    await this._event(\"clear\");\n    return true;\n  }\n\n  /**\n   * Reads the current audio stream data\n   * @returns {Promise<{meanValues: Float32Array, channels: Array<Float32Array>}>}\n   */\n  async read() {\n    if (!this.processor) {\n      throw new Error(\"Session ended: please call .begin() first\");\n    }\n    this.log(\"Reading ...\");\n    const result = await this._event(\"read\");\n    return result;\n  }\n\n  /**\n   * Saves the current audio stream to a file\n   * @param {boolean} [force] Force saving while still recording\n   * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}\n   */\n  async save(force = false) {\n    if (!this.processor) {\n      throw new Error(\"Session ended: please call .begin() first\");\n    }\n    if (!force && this.recording) {\n      throw new Error(\n        \"Currently recording: please call .pause() first, or call .save(true) to force\"\n      );\n    }\n    this.log(\"Exporting ...\");\n    const exportData = await this._event(\"export\");\n    const packer = new WavPacker();\n    const result = packer.pack(this.sampleRate, exportData.audio);\n    return result;\n  }\n\n  /**\n   * Ends the current recording session and saves the result\n   * @returns {Promise<import('./wav_packer.js').WavPackerAudioType>}\n   */\n  async end() {\n    if (!this.processor) {\n      throw new Error(\"Session ended: please call .begin() first\");\n    }\n\n    const _processor = this.processor;\n\n    this.log(\"Stopping ...\");\n    await this._event(\"stop\");\n    this.recording = false;\n\n    this.log(\"Exporting ...\");\n    const exportData = await this._event(\"export\", {}, _processor);\n\n    this.processor.disconnect();\n    this.source.disconnect();\n    this.node.disconnect();\n    this.analyser.disconnect();\n    this.stream = null;\n    this.processor = null;\n    this.source = null;\n    this.node = null;\n\n    const packer = new WavPacker();\n    const result = packer.pack(this.sampleRate, exportData.audio);\n    return result;\n  }\n\n  /**\n   * Performs a full cleanup of WavRecorder instance\n   * Stops actively listening via microphone and removes existing listeners\n   * @returns {Promise<true>}\n   */\n  async quit() {\n    this.listenForDeviceChange(null);\n    if (this.processor) {\n      await this.end();\n    }\n    return true;\n  }\n}\n\nglobalThis.WavRecorder = WavRecorder;\n","import { MediaManager } from \"./mediaManager\";\nimport { MediaStreamRecorder, WavStreamPlayer } from \"../wavtools\";\n\nimport Daily, {\n  DailyCall,\n  DailyCameraErrorObject,\n  DailyCameraErrorType,\n  DailyEventObjectAvailableDevicesUpdated,\n  DailyEventObjectCameraError,\n  DailyEventObjectLocalAudioLevel,\n  DailyEventObjectSelectedDevicesUpdated,\n  DailyEventObjectTrack,\n  DailyParticipant,\n  DailyParticipantsObject,\n} from \"@daily-co/daily-js\";\nimport {\n  DeviceArray,\n  DeviceError,\n  Participant,\n  Tracks,\n} from \"@pipecat-ai/client-js\";\n\nexport class DailyMediaManager extends MediaManager {\n  private _daily: DailyCall;\n  private _mediaStreamRecorder: MediaStreamRecorder | undefined;\n  private _wavStreamPlayer: WavStreamPlayer | undefined;\n\n  private _initialized: boolean;\n  private _connected: boolean;\n  private _connectResolve: ((value: void | PromiseLike<void>) => void) | null;\n\n  private _currentAudioTrack: MediaStreamTrack | null;\n  private _selectedCam: MediaDeviceInfo | Record<string, never> = {};\n  private _selectedMic: MediaDeviceInfo | Record<string, never> = {};\n  private _selectedSpeaker: MediaDeviceInfo | Record<string, never> = {};\n\n  private _remoteAudioLevelInterval: NodeJS.Timeout | null = null;\n\n  private onTrackStartedCallback?: (event: DailyEventObjectTrack) => void;\n  private onTrackStoppedCallback?: (event: DailyEventObjectTrack) => void;\n\n  private _recorderChunkSize: number | undefined = undefined;\n\n  constructor(\n    enablePlayer: boolean = true,\n    enableRecording: boolean = true,\n    onTrackStartedCallback?: (event: DailyEventObjectTrack) => void,\n    onTrackStoppedCallback?: (event: DailyEventObjectTrack) => void,\n    recorderChunkSize: number | undefined = undefined,\n    recorderSampleRate: number = 24000,\n    playerSampleRate: number = 24000,\n  ) {\n    super();\n    this._initialized = false;\n    this._connected = false;\n    this._currentAudioTrack = null;\n    this._connectResolve = null;\n    this.onTrackStartedCallback = onTrackStartedCallback;\n    this.onTrackStoppedCallback = onTrackStoppedCallback;\n    this._recorderChunkSize = recorderChunkSize;\n\n    this._supportsScreenShare = true;\n\n    this._daily = Daily.getCallInstance() ?? Daily.createCallObject();\n\n    if (enableRecording) {\n      this._mediaStreamRecorder = new MediaStreamRecorder({\n        sampleRate: recorderSampleRate,\n      });\n    }\n    if (enablePlayer) {\n      this._wavStreamPlayer = new WavStreamPlayer({\n        sampleRate: playerSampleRate,\n      });\n    }\n\n    this._daily.on(\"track-started\", this.handleTrackStarted.bind(this));\n    this._daily.on(\"track-stopped\", this.handleTrackStopped.bind(this));\n    this._daily.on(\n      \"available-devices-updated\",\n      this._handleAvailableDevicesUpdated.bind(this),\n    );\n    this._daily.on(\n      \"selected-devices-updated\",\n      this._handleSelectedDevicesUpdated.bind(this),\n    );\n    this._daily.on(\"camera-error\", this.handleDeviceError.bind(this));\n    this._daily.on(\"local-audio-level\", this._handleLocalAudioLevel.bind(this));\n  }\n\n  async initialize(): Promise<void> {\n    if (this._initialized) {\n      console.warn(\"DailyMediaManager already initialized\");\n      return;\n    }\n    const infos = await this._daily.startCamera({\n      startVideoOff: !this._camEnabled,\n      startAudioOff: !this._micEnabled,\n      dailyConfig: { useDevicePreferenceCookies: true },\n    });\n    const { devices } = await this._daily.enumerateDevices();\n    const cams = devices.filter((d) => d.kind === \"videoinput\");\n    const mics = devices.filter((d) => d.kind === \"audioinput\");\n    const speakers = devices.filter((d) => d.kind === \"audiooutput\");\n    this._callbacks.onAvailableCamsUpdated?.(cams);\n    this._callbacks.onAvailableMicsUpdated?.(mics);\n    this._callbacks.onAvailableSpeakersUpdated?.(speakers);\n    this._selectedCam = infos.camera;\n    this._callbacks.onCamUpdated?.(infos.camera as MediaDeviceInfo);\n    this._selectedMic = infos.mic;\n    this._callbacks.onMicUpdated?.(infos.mic as MediaDeviceInfo);\n    this._selectedSpeaker = infos.speaker;\n    this._callbacks.onSpeakerUpdated?.(infos.speaker as MediaDeviceInfo);\n\n    // Instantiate audio observers\n    if (!this._daily.isLocalAudioLevelObserverRunning())\n      await this._daily.startLocalAudioLevelObserver(100);\n\n    if (this._wavStreamPlayer) {\n      await this._wavStreamPlayer.connect();\n      if (!this._remoteAudioLevelInterval) {\n        this._remoteAudioLevelInterval = setInterval(() => {\n          const frequencies = this._wavStreamPlayer!.getFrequencies();\n          let aveVal = 0;\n          if (frequencies.values?.length) {\n            aveVal =\n              frequencies.values.reduce((a, c) => a + c, 0) /\n              frequencies.values.length;\n          }\n          this._handleRemoteAudioLevel(aveVal);\n        }, 100);\n      }\n    }\n    this._initialized = true;\n  }\n\n  async connect(): Promise<void> {\n    if (this._connected) {\n      console.warn(\"DailyMediaManager already connected\");\n      return;\n    }\n    this._connected = true;\n    if (!this._initialized) {\n      return new Promise((resolve) => {\n        (async () => {\n          this._connectResolve = resolve;\n          await this.initialize();\n        })();\n      });\n    }\n    if (this._micEnabled) {\n      this._startRecording();\n    }\n  }\n\n  async disconnect(): Promise<void> {\n    if (this._remoteAudioLevelInterval) {\n      clearInterval(this._remoteAudioLevelInterval);\n    }\n    this._remoteAudioLevelInterval = null;\n    this._daily.leave();\n    this._currentAudioTrack = null;\n    await this._mediaStreamRecorder?.end();\n    this._wavStreamPlayer?.interrupt();\n    this._initialized = false;\n    this._connected = false;\n  }\n\n  async userStartedSpeaking(): Promise<unknown> {\n    return this._wavStreamPlayer?.interrupt();\n  }\n\n  bufferBotAudio(\n    data: ArrayBuffer | Int16Array,\n    id?: string,\n  ): Int16Array | undefined {\n    return this._wavStreamPlayer?.add16BitPCM(data, id);\n  }\n\n  async getAllMics(): Promise<MediaDeviceInfo[]> {\n    let devices = (await this._daily.enumerateDevices()).devices;\n    return devices.filter((device) => device.kind === \"audioinput\");\n  }\n  async getAllCams(): Promise<MediaDeviceInfo[]> {\n    let devices = (await this._daily.enumerateDevices()).devices;\n    return devices.filter((device) => device.kind === \"videoinput\");\n  }\n  async getAllSpeakers(): Promise<MediaDeviceInfo[]> {\n    let devices = (await this._daily.enumerateDevices()).devices;\n    return devices.filter((device) => device.kind === \"audiooutput\");\n  }\n\n  updateMic(micId: string) {\n    this._daily\n      .setInputDevicesAsync({ audioDeviceId: micId })\n      .then((deviceInfo) => {\n        this._selectedMic = deviceInfo.mic;\n      });\n  }\n  updateCam(camId: string) {\n    this._daily\n      .setInputDevicesAsync({ videoDeviceId: camId })\n      .then((deviceInfo) => {\n        this._selectedCam = deviceInfo.camera;\n      });\n  }\n  async updateSpeaker(speakerId: string): Promise<void> {\n    if (speakerId !== \"default\" && this._selectedSpeaker.deviceId === speakerId)\n      return;\n    let sID = speakerId;\n    if (sID === \"default\") {\n      const speakers = await this.getAllSpeakers();\n      const defaultSpeaker = speakers.find((s) => s.deviceId === \"default\");\n      if (!defaultSpeaker) {\n        console.warn(\"No default speaker found\");\n        return;\n      }\n      speakers.splice(speakers.indexOf(defaultSpeaker), 1);\n      const defaultSpeakerCp = speakers.find((s) =>\n        defaultSpeaker.label.includes(s.label),\n      );\n      sID = defaultSpeakerCp?.deviceId ?? speakerId;\n    }\n    this._wavStreamPlayer?.updateSpeaker(sID).then(() => {\n      this._selectedSpeaker = { deviceId: speakerId } as MediaDeviceInfo;\n      this._callbacks.onSpeakerUpdated?.(this._selectedSpeaker);\n    });\n  }\n\n  get selectedMic(): MediaDeviceInfo | Record<string, never> {\n    return this._selectedMic;\n  }\n  get selectedCam(): MediaDeviceInfo | Record<string, never> {\n    return this._selectedCam;\n  }\n  get selectedSpeaker(): MediaDeviceInfo | Record<string, never> {\n    return this._selectedSpeaker;\n  }\n\n  async enableMic(enable: boolean): Promise<void> {\n    this._micEnabled = enable;\n    if (!this._daily.participants()?.local) return;\n    this._daily.setLocalAudio(enable);\n    if (this._mediaStreamRecorder) {\n      if (enable) {\n        if (this._mediaStreamRecorder.getStatus() === \"paused\") {\n          this._startRecording();\n        } // else, we'll record on the track-started event\n      } else {\n        if (this._mediaStreamRecorder.getStatus() === \"recording\") {\n          this._mediaStreamRecorder.pause();\n        }\n      }\n    }\n  }\n  enableCam(enable: boolean): void {\n    this._camEnabled = enable;\n    this._daily.setLocalVideo(enable);\n  }\n  enableScreenShare(enable: boolean): void {\n    if (enable) {\n      this._daily.startScreenShare();\n    } else {\n      this._daily.stopScreenShare();\n    }\n  }\n\n  get isCamEnabled(): boolean {\n    return this._daily.localVideo();\n  }\n  get isMicEnabled(): boolean {\n    return this._daily.localAudio();\n  }\n  get isSharingScreen(): boolean {\n    return this._daily.localScreenAudio() || this._daily.localScreenVideo();\n  }\n\n  tracks(): Tracks {\n    const participants: DailyParticipantsObject = this._daily.participants();\n    return {\n      local: {\n        audio: participants?.local?.tracks?.audio?.persistentTrack,\n        screenAudio: participants?.local?.tracks?.screenAudio?.persistentTrack,\n        screenVideo: participants?.local?.tracks?.screenVideo?.persistentTrack,\n        video: participants?.local?.tracks?.video?.persistentTrack,\n      },\n    };\n  }\n\n  private _startRecording(): void {\n    if (!this._connected || !this._mediaStreamRecorder) return;\n    try {\n      this._mediaStreamRecorder.record((data) => {\n        this._userAudioCallback(data.mono);\n      }, this._recorderChunkSize);\n    } catch (e) {\n      const err = e as Error;\n      if (!err.message.includes(\"Already recording\")) {\n        console.error(\"Error starting recording\", e);\n      }\n    }\n  }\n\n  private _handleAvailableDevicesUpdated(\n    event: DailyEventObjectAvailableDevicesUpdated,\n  ) {\n    this._callbacks.onAvailableCamsUpdated?.(\n      event.availableDevices.filter((d) => d.kind === \"videoinput\"),\n    );\n    this._callbacks.onAvailableMicsUpdated?.(\n      event.availableDevices.filter((d) => d.kind === \"audioinput\"),\n    );\n    this._callbacks.onAvailableSpeakersUpdated?.(\n      event.availableDevices.filter((d) => d.kind === \"audiooutput\"),\n    );\n    if (this._selectedSpeaker.deviceId === \"default\") {\n      this.updateSpeaker(\"default\");\n    }\n  }\n\n  private _handleSelectedDevicesUpdated(\n    event: DailyEventObjectSelectedDevicesUpdated,\n  ) {\n    if (this._selectedCam?.deviceId !== event.devices.camera) {\n      this._selectedCam = event.devices.camera;\n      this._callbacks.onCamUpdated?.(event.devices.camera as MediaDeviceInfo);\n    }\n    if (this._selectedMic?.deviceId !== event.devices.mic) {\n      this._selectedMic = event.devices.mic;\n      this._callbacks.onMicUpdated?.(event.devices.mic as MediaDeviceInfo);\n    }\n  }\n\n  private handleDeviceError(ev: DailyEventObjectCameraError) {\n    const generateDeviceError = (\n      error: DailyCameraErrorObject<DailyCameraErrorType>,\n    ) => {\n      const devices: DeviceArray = [];\n      switch (error.type) {\n        case \"permissions\": {\n          error.blockedMedia.forEach((d) => {\n            devices.push(d === \"video\" ? \"cam\" : \"mic\");\n          });\n          return new DeviceError(devices, error.type, error.msg, {\n            blockedBy: error.blockedBy,\n          });\n        }\n        case \"not-found\": {\n          error.missingMedia.forEach((d) => {\n            devices.push(d === \"video\" ? \"cam\" : \"mic\");\n          });\n          return new DeviceError(devices, error.type, error.msg);\n        }\n        case \"constraints\": {\n          error.failedMedia.forEach((d) => {\n            devices.push(d === \"video\" ? \"cam\" : \"mic\");\n          });\n          return new DeviceError(devices, error.type, error.msg, {\n            reason: error.reason,\n          });\n        }\n        case \"cam-in-use\": {\n          devices.push(\"cam\");\n          return new DeviceError(devices, \"in-use\", error.msg);\n        }\n        case \"mic-in-use\": {\n          devices.push(\"mic\");\n          return new DeviceError(devices, \"in-use\", error.msg);\n        }\n        case \"cam-mic-in-use\": {\n          devices.push(\"cam\");\n          devices.push(\"mic\");\n          return new DeviceError(devices, \"in-use\", error.msg);\n        }\n        case \"undefined-mediadevices\":\n        case \"unknown\":\n        default: {\n          devices.push(\"cam\");\n          devices.push(\"mic\");\n          return new DeviceError(devices, error.type, error.msg);\n        }\n      }\n    };\n    this._callbacks.onDeviceError?.(generateDeviceError(ev.error));\n  }\n\n  private _handleLocalAudioLevel(ev: DailyEventObjectLocalAudioLevel) {\n    this._callbacks.onLocalAudioLevel?.(ev.audioLevel);\n  }\n\n  private _handleRemoteAudioLevel(audioLevel: number) {\n    this._callbacks.onRemoteAudioLevel?.(audioLevel, botParticipant());\n  }\n\n  protected async handleTrackStarted(event: DailyEventObjectTrack) {\n    if (!event.participant?.local) return;\n    if (event.track.kind === \"audio\") {\n      if (this._mediaStreamRecorder) {\n        const status = this._mediaStreamRecorder.getStatus();\n        switch (status) {\n          case \"ended\":\n            try {\n              await this._mediaStreamRecorder.begin(event.track);\n              if (this._connected) {\n                this._startRecording();\n                if (this._connectResolve) {\n                  this._connectResolve();\n                  this._connectResolve = null;\n                }\n              }\n            } catch (e) {\n              // void. nothing to do.\n            }\n            break;\n          case \"paused\":\n            this._startRecording();\n            break;\n          case \"recording\":\n          default:\n            if (this._currentAudioTrack !== event.track) {\n              await this._mediaStreamRecorder.end();\n              try {\n                await this._mediaStreamRecorder.begin(event.track);\n                this._startRecording();\n              } catch (e) {\n                // void. nothing to do.\n              }\n            } else {\n              console.warn(\n                \"track-started event received for current track and already recording\",\n              );\n            }\n            break;\n        }\n      }\n      this._currentAudioTrack = event.track;\n    }\n    this._callbacks.onTrackStarted?.(\n      event.track,\n      event.participant\n        ? dailyParticipantToParticipant(event.participant)\n        : undefined,\n    );\n    this.onTrackStartedCallback?.(event);\n  }\n\n  protected handleTrackStopped(event: DailyEventObjectTrack) {\n    if (!event.participant?.local) return;\n    if (event.track.kind === \"audio\") {\n      if (\n        this._mediaStreamRecorder &&\n        this._mediaStreamRecorder.getStatus() === \"recording\"\n      ) {\n        this._mediaStreamRecorder.pause();\n      }\n    }\n    this._callbacks.onTrackStopped?.(\n      event.track,\n      event.participant\n        ? dailyParticipantToParticipant(event.participant)\n        : undefined,\n    );\n    this.onTrackStoppedCallback?.(event);\n  }\n}\n\nconst dailyParticipantToParticipant = (p: DailyParticipant): Participant => ({\n  id: p.user_id,\n  local: p.local,\n  name: p.user_name,\n});\n\nconst botParticipant = () => ({\n  id: \"bot\",\n  local: false,\n  name: \"Bot\",\n});\n","import cloneDeep from \"lodash/cloneDeep\";\nimport {\n  logger,\n  makeRequest,\n  RTVIError,\n  RTVIMessage,\n  PipecatClientOptions,\n  Tracks,\n  Transport,\n  TransportStartError,\n  TransportState,\n  UnsupportedFeatureError,\n  APIRequest,\n  isAPIRequest,\n} from \"@pipecat-ai/client-js\";\nimport { MediaManager } from \"../../../lib/media-mgmt/mediaManager\";\nimport { DailyMediaManager } from \"../../../lib/media-mgmt/dailyMediaManager\";\n\nclass TrackStatusMessage {\n  type = \"trackStatus\";\n  receiver_index: number;\n  enabled: boolean;\n  constructor(receiver_index: number, enabled: boolean) {\n    this.receiver_index = receiver_index;\n    this.enabled = enabled;\n  }\n}\n\nclass WebRTCTrack {\n  track: MediaStreamTrack;\n  status: \"new\" | \"muted\" | \"unmuted\" | \"ended\";\n\n  constructor(track: MediaStreamTrack) {\n    this.track = track;\n    this.status = \"new\";\n  }\n}\n\nexport type IceConfig = {\n  iceServers?: RTCIceServer[];\n};\n\nexport type SmallWebRTCTransportConnectionOptions = {\n  /** @deprecated Use webrtcRequestParams instead */\n  connectionUrl?: string;\n  /** @deprecated Use webrtcRequestParams instead */\n  webrtcUrl?: string;\n  webrtcRequestParams?: APIRequest;\n  iceConfig?: IceConfig;\n};\n\nexport interface SmallWebRTCTransportConstructorOptions\n  extends SmallWebRTCTransportConnectionOptions {\n  iceServers?: RTCIceServer[];\n  waitForICEGathering?: boolean;\n  audioCodec?: string;\n  videoCodec?: string;\n  mediaManager?: MediaManager;\n}\n\nconst RENEGOTIATE_TYPE = \"renegotiate\";\nclass RenegotiateMessage {\n  type = RENEGOTIATE_TYPE;\n}\n\nconst PEER_LEFT_TYPE = \"peerLeft\";\nclass PeerLeftMessageMessage {\n  type = PEER_LEFT_TYPE;\n}\n\ntype OutboundSignallingMessage = TrackStatusMessage;\n\ntype InboundSignallingMessage = RenegotiateMessage | PeerLeftMessageMessage;\n\n// Interface for the structure of the signalling message\nconst SIGNALLING_TYPE = \"signalling\";\nclass SignallingMessageObject {\n  type: typeof SIGNALLING_TYPE = SIGNALLING_TYPE;\n  message: InboundSignallingMessage | OutboundSignallingMessage;\n  constructor(message: InboundSignallingMessage | OutboundSignallingMessage) {\n    this.message = message;\n  }\n}\n\nconst AUDIO_TRANSCEIVER_INDEX = 0;\nconst VIDEO_TRANSCEIVER_INDEX = 1;\nconst SCREEN_VIDEO_TRANSCEIVER_INDEX = 2;\n\n/**\n * SmallWebRTCTransport is a class that provides a client-side\n * interface for connecting to the SmallWebRTCTransport provided by Pipecat\n */\nexport class SmallWebRTCTransport extends Transport {\n  public static SERVICE_NAME = \"small-webrtc-transport\";\n\n  private _webrtcRequest: APIRequest | null = null;\n\n  // Trigger when the peer connection is finally ready or in case it has failed all the attempts to connect\n  private _connectResolved: ((value: PromiseLike<void> | void) => void) | null =\n    null;\n  private _connectFailed: ((reason?: any) => void) | null = null;\n\n  // Utilities for audio.\n  declare private mediaManager: MediaManager;\n\n  private pc: RTCPeerConnection | null = null;\n  private dc: RTCDataChannel | null = null;\n  private audioCodec: string | null | \"default\" = null;\n  private videoCodec: string | null | \"default\" = null;\n  private pc_id: string | null = null;\n\n  private reconnectionAttempts = 0;\n  private maxReconnectionAttempts = 3;\n  private isReconnecting = false;\n  private keepAliveInterval: number | null = null;\n\n  private _iceServers: RTCIceServer[] = [];\n  private readonly _waitForICEGathering: boolean;\n\n  private _incomingTracks: Map<string, WebRTCTrack> = new Map();\n\n  private _canSendIceCandidates: boolean = false;\n  private _candidateQueue: RTCIceCandidate[] = [];\n  private __flushTimeout: ReturnType<typeof setTimeout> | null = null;\n  private _flushDelay = 200;\n\n  constructor(opts: SmallWebRTCTransportConstructorOptions = {}) {\n    super();\n    this._iceServers = opts.iceServers ?? [];\n    this._waitForICEGathering = opts.waitForICEGathering ?? false;\n    this.audioCodec = opts.audioCodec ?? null;\n    this.videoCodec = opts.videoCodec ?? null;\n\n    this._webrtcRequest = this._resolveRequestInfo(opts);\n\n    this.mediaManager =\n      opts.mediaManager ||\n      new DailyMediaManager(\n        false,\n        false,\n        async (event) => {\n          if (!this.pc) {\n            return;\n          }\n          if (event.type == \"audio\") {\n            logger.info(\"SmallWebRTCMediaManager replacing audio track\");\n            await this.getAudioTransceiver().sender.replaceTrack(event.track);\n          } else if (event.type == \"video\") {\n            logger.info(\"SmallWebRTCMediaManager replacing video track\");\n            await this.getVideoTransceiver().sender.replaceTrack(event.track);\n          } else if (event.type == \"screenVideo\") {\n            logger.info(\"SmallWebRTCMediaManager replacing screen video track\");\n            await this.getScreenVideoTransceiver().sender.replaceTrack(\n              event.track,\n            );\n          } else if (event.type == \"screenAudio\") {\n            logger.info(\n              \"SmallWebRTCMediaManager does not yet support screen audio. Track is ignored.\",\n            );\n          }\n        },\n        (event) =>\n          logger.debug(\"SmallWebRTCMediaManager Track stopped:\", event),\n      );\n  }\n\n  public initialize(\n    options: PipecatClientOptions,\n    messageHandler: (ev: RTVIMessage) => void,\n  ): void {\n    this._options = options;\n    this._callbacks = options.callbacks ?? {};\n    this._onMessage = messageHandler;\n    this.mediaManager.setClientOptions(options);\n\n    this.state = \"disconnected\";\n    logger.debug(\"[RTVI Transport] Initialized\");\n  }\n\n  async initDevices() {\n    this.state = \"initializing\";\n    await this.mediaManager.initialize();\n    this.state = \"initialized\";\n  }\n\n  setAudioCodec(audioCodec: string | null): void {\n    this.audioCodec = audioCodec;\n  }\n\n  setVideoCodec(videoCodec: string | null): void {\n    this.videoCodec = videoCodec;\n  }\n\n  _resolveRequestInfo(\n    params:\n      | SmallWebRTCTransportConstructorOptions\n      | SmallWebRTCTransportConnectionOptions,\n  ): APIRequest | null {\n    let requestInfo: APIRequest | null = null;\n    const _webrtcUrl = params.webrtcUrl ?? params.connectionUrl ?? null;\n    if (_webrtcUrl) {\n      const key = params.webrtcUrl ? \"webrtcUrl\" : \"connectionUrl\";\n      logger.warn(`${key} is deprecated. Use webrtcRequestParams instead.`);\n      if (params.webrtcRequestParams) {\n        logger.warn(\n          `Both ${key} and webrtcRequestParams provided. Using webrtcRequestParams.`,\n        );\n      } else {\n        if (typeof _webrtcUrl === \"string\") {\n          requestInfo = { endpoint: _webrtcUrl };\n        } else {\n          logger.error(`Invalid ${key} provided in params. Ignoring.`);\n        }\n      }\n    }\n    if (params.webrtcRequestParams) {\n      if (isAPIRequest(params.webrtcRequestParams)) {\n        // Override any previous request set in the constructor, do not try to merge\n        requestInfo = params.webrtcRequestParams;\n      } else {\n        logger.error(\n          `Invalid webrtcRequestParams provided in params. Ignoring.`,\n        );\n      }\n    }\n    return requestInfo ?? this._webrtcRequest;\n  }\n\n  _getStartEndpointAsString(): string | undefined {\n    const startEndpoint = this.startBotParams?.endpoint;\n    switch (typeof startEndpoint) {\n      case \"string\":\n        return startEndpoint;\n      case \"object\":\n        if (startEndpoint instanceof URL) {\n          return startEndpoint.toString();\n        }\n        if (startEndpoint instanceof Request) {\n          return startEndpoint.url;\n        }\n    }\n    return;\n  }\n\n  private _isValidObject(value: unknown): value is object {\n    if (value === null || value === undefined) return false;\n    if (typeof value !== \"object\") {\n      throw new RTVIError(\"Invalid connection parameters\");\n    }\n    return true;\n  }\n\n  private _fixConnectionOptionsParams(\n    params: Record<string, any>,\n    supportedKeys: string[],\n  ): SmallWebRTCTransportConnectionOptions {\n    const snakeToCamel = (snakeCaseString: string) => {\n      return snakeCaseString.replace(/_([a-z,A-Z])/g, (_, letter) =>\n        letter.toUpperCase(),\n      );\n    };\n\n    let result: SmallWebRTCTransportConnectionOptions = {};\n    let sessionId;\n    for (const [key, val] of Object.entries(params)) {\n      const camelKey = snakeToCamel(key);\n      if (camelKey === \"sessionId\") {\n        sessionId = val;\n        continue;\n      }\n      if (!supportedKeys.includes(camelKey)) {\n        logger.warn(`Unrecognized connection parameter: ${key}. Ignored.`);\n        continue;\n      }\n      result[camelKey as keyof SmallWebRTCTransportConnectionOptions] =\n        val as any;\n    }\n\n    if (sessionId && this._shouldUseStartBotFallback(result)) {\n      result.webrtcRequestParams =\n        this._buildRequestParamsBasedOnStartBotParams(sessionId);\n    }\n\n    return result;\n  }\n\n  private _shouldUseStartBotFallback(\n    options: SmallWebRTCTransportConnectionOptions,\n  ): boolean {\n    const hasStartEndpoint = !!this._getStartEndpointAsString();\n\n    const hasNoConnectionParams =\n      !options.webrtcUrl &&\n      !options.connectionUrl &&\n      !options.webrtcRequestParams;\n\n    return hasStartEndpoint && hasNoConnectionParams;\n  }\n\n  private _buildRequestParamsBasedOnStartBotParams(\n    sessionId: string,\n  ): APIRequest {\n    const startEndpoint = this._getStartEndpointAsString()!;\n    const offerUrl = startEndpoint.replace(\n      \"/start\",\n      `/sessions/${sessionId}/api/offer`,\n    );\n    return {\n      endpoint: offerUrl,\n      headers: this.startBotParams!.headers,\n    };\n  }\n\n  _validateConnectionParams(\n    connectParams: unknown,\n  ): SmallWebRTCTransportConnectionOptions | undefined {\n    if (!this._isValidObject(connectParams)) return undefined;\n\n    const params = connectParams as Record<string, any>;\n\n    const supportedKeys = [\n      \"webrtcUrl\",\n      \"connectionUrl\",\n      \"webrtcRequestParams\",\n      \"iceConfig\",\n    ];\n\n    const fixedParams = this._fixConnectionOptionsParams(params, supportedKeys);\n    const webrtcRequestParams = this._resolveRequestInfo(fixedParams);\n    if (webrtcRequestParams) {\n      fixedParams.webrtcRequestParams = webrtcRequestParams;\n    }\n    delete fixedParams.connectionUrl;\n    delete fixedParams.webrtcUrl;\n\n    if (Object.keys(fixedParams).length === 0) {\n      return undefined;\n    }\n    return fixedParams;\n  }\n\n  async _connect(\n    connectParams?: SmallWebRTCTransportConnectionOptions,\n  ): Promise<void> {\n    if (this._abortController?.signal.aborted) return;\n\n    this.state = \"connecting\";\n\n    if (connectParams?.iceConfig?.iceServers) {\n      this._iceServers = connectParams?.iceConfig?.iceServers;\n    }\n\n    // Note: There is no need to validate the params here, as they were already\n    //       validated and fixed in the parent class's connect() method (which calls\n    //       _validateConnectionParams() and passes the result to _connect()).\n    this._webrtcRequest =\n      connectParams?.webrtcRequestParams ?? this._webrtcRequest;\n    if (!this._webrtcRequest) {\n      logger.error(\"No request details provided for WebRTC connection\");\n      this.state = \"error\";\n      throw new TransportStartError();\n    }\n\n    await this.mediaManager.connect();\n\n    await this.startNewPeerConnection();\n\n    if (this._abortController?.signal.aborted) return;\n\n    if (this.dc?.readyState !== \"open\") {\n      // Wait until we are actually connected and the data channel is ready\n      await new Promise<void>((resolve, reject) => {\n        this._connectResolved = resolve;\n        this._connectFailed = reject;\n      });\n    }\n\n    this.state = \"connected\";\n    this._callbacks.onConnected?.();\n  }\n\n  private syncTrackStatus() {\n    // Sending the current status from the tracks to Pipecat\n    this.sendSignallingMessage(\n      new TrackStatusMessage(\n        AUDIO_TRANSCEIVER_INDEX,\n        this.mediaManager.isMicEnabled,\n      ),\n    );\n    this.sendSignallingMessage(\n      new TrackStatusMessage(\n        VIDEO_TRANSCEIVER_INDEX,\n        this.mediaManager.isCamEnabled,\n      ),\n    );\n    if (this.mediaManager.supportsScreenShare) {\n      this.sendSignallingMessage(\n        new TrackStatusMessage(\n          SCREEN_VIDEO_TRANSCEIVER_INDEX,\n          this.mediaManager.isSharingScreen &&\n            !!this.mediaManager.tracks().local.screenVideo,\n        ),\n      );\n    }\n  }\n\n  sendReadyMessage() {\n    this.state = \"ready\";\n    // Sending message that the client is ready, just for testing\n    //this.dc?.send(JSON.stringify({id: 'clientReady', label: 'rtvi-ai', type:'client-ready'}))\n    this.sendMessage(RTVIMessage.clientReady());\n  }\n\n  sendMessage(message: RTVIMessage) {\n    if (!this.dc || this.dc.readyState !== \"open\") {\n      logger.warn(`Datachannel is not ready. Message not sent: ${message}`);\n      return;\n    }\n    this.dc?.send(JSON.stringify(message));\n  }\n\n  private sendSignallingMessage(message: OutboundSignallingMessage) {\n    if (!this.dc || this.dc.readyState !== \"open\") {\n      logger.warn(`Datachannel is not ready. Message not sent: ${message}`);\n      return;\n    }\n    const signallingMessage = new SignallingMessageObject(message);\n    this.dc?.send(JSON.stringify(signallingMessage));\n  }\n\n  async _disconnect(): Promise<void> {\n    this.state = \"disconnecting\";\n    await this.stop();\n    this.state = \"disconnected\";\n  }\n\n  private createPeerConnection(): RTCPeerConnection {\n    const config: RTCConfiguration = {\n      iceServers: this._iceServers,\n    };\n\n    let pc = new RTCPeerConnection(config);\n\n    pc.onicecandidate = async (event) => {\n      if (event.candidate) {\n        logger.debug(\"New ICE candidate:\", event.candidate);\n        await this.sendIceCandidate(event.candidate);\n      } else {\n        logger.info(\"All ICE candidates have been sent.\");\n      }\n    };\n\n    pc.addEventListener(\"icegatheringstatechange\", () => {\n      if (\n        pc.iceGatheringState === \"complete\" &&\n        pc.iceConnectionState === \"checking\" &&\n        this._waitForICEGathering\n      ) {\n        logger.info(\n          \"Ice gathering completed and connection is still checking. Trying to reconnect.\",\n        );\n        // If ICE gathering has completed and the previous connection was still in the \"checking\" state,\n        // we will reconnect to use all the new ICE candidates.\n        // void this.attemptReconnection(false);\n      }\n    });\n\n    pc.addEventListener(\"iceconnectionstatechange\", () =>\n      this.handleICEConnectionStateChange(),\n    );\n\n    logger.debug(`iceConnectionState: ${pc.iceConnectionState}`);\n\n    pc.addEventListener(\"signalingstatechange\", () => {\n      logger.debug(`signalingState: ${this.pc!.signalingState}`);\n      if (this.pc!.signalingState == \"stable\") {\n        this.handleReconnectionCompleted();\n      }\n    });\n    logger.debug(`signalingState: ${pc.signalingState}`);\n\n    pc.addEventListener(\"track\", (evt: RTCTrackEvent) => {\n      const streamType = evt.transceiver\n        ? evt.transceiver.mid === \"0\"\n          ? \"microphone\"\n          : evt.transceiver.mid === \"1\"\n            ? \"camera\"\n            : \"screenVideo\"\n        : null;\n      if (!streamType) {\n        logger.warn(\"Received track without transceiver mid\", evt);\n        return;\n      }\n      logger.debug(`Received new remote track for ${streamType}`);\n      this._incomingTracks.set(streamType, new WebRTCTrack(evt.track));\n      evt.track.addEventListener(\"unmute\", () => {\n        const t = this._incomingTracks.get(streamType);\n        if (!t) return;\n        logger.debug(`Remote track unmuted: ${streamType}`);\n        t.status = \"unmuted\";\n        this._callbacks.onTrackStarted?.(evt.track);\n      });\n      evt.track.addEventListener(\"mute\", () => {\n        const t = this._incomingTracks.get(streamType);\n        if (!t || t.status !== \"unmuted\") return;\n        logger.debug(`Remote track muted: ${streamType}`);\n        t.status = \"muted\";\n        this._callbacks.onTrackStopped?.(evt.track);\n      });\n      evt.track.addEventListener(\"ended\", () => {\n        logger.debug(`Remote track ended: ${streamType}`);\n        this._callbacks.onTrackStopped?.(evt.track);\n        this._incomingTracks.delete(streamType);\n      });\n    });\n\n    return pc;\n  }\n\n  private handleICEConnectionStateChange(): void {\n    if (!this.pc) return;\n    logger.debug(`ICE Connection State: ${this.pc.iceConnectionState}`);\n\n    if (this.pc.iceConnectionState === \"failed\") {\n      logger.debug(\"ICE connection failed, attempting restart.\");\n      void this.attemptReconnection(true);\n    } else if (this.pc.iceConnectionState === \"disconnected\") {\n      // Waiting before trying to reconnect to see if it handles it automatically\n      setTimeout(() => {\n        if (this.pc?.iceConnectionState === \"disconnected\") {\n          logger.debug(\"Still disconnected, attempting reconnection.\");\n          void this.attemptReconnection(true);\n        }\n      }, 5000);\n    }\n  }\n\n  private handleReconnectionCompleted() {\n    this.reconnectionAttempts = 0;\n    this.isReconnecting = false;\n  }\n\n  private async attemptReconnection(\n    recreatePeerConnection: boolean = false,\n  ): Promise<void> {\n    if (this.isReconnecting) {\n      logger.debug(\"Reconnection already in progress, skipping.\");\n      return;\n    }\n    if (this.reconnectionAttempts >= this.maxReconnectionAttempts) {\n      logger.debug(\"Max reconnection attempts reached. Stopping transport.\");\n      await this.stop();\n      return;\n    }\n    this.isReconnecting = true;\n    this.reconnectionAttempts++;\n    logger.debug(`Reconnection attempt ${this.reconnectionAttempts}...`);\n    // aiortc does not seem to work when just trying to restart the ice\n    // so for this case we create a new peer connection on both sides\n    if (recreatePeerConnection) {\n      const oldPC = this.pc;\n      await this.startNewPeerConnection(recreatePeerConnection);\n      if (oldPC) {\n        logger.debug(\"closing old peer connection\");\n        this.closePeerConnection(oldPC);\n      }\n    } else {\n      await this.negotiate();\n    }\n  }\n\n  private async waitForIceGatheringComplete(timeoutMs = 2000): Promise<void> {\n    const pc = this.pc!;\n    if (pc.iceGatheringState === \"complete\") return;\n\n    logger.info(\n      \"Waiting for ICE gathering to complete. Current state:\",\n      pc.iceGatheringState,\n    );\n\n    return new Promise<void>((resolve) => {\n      let timeoutId: ReturnType<typeof setTimeout>;\n      const cleanup = () => {\n        pc.removeEventListener(\"icegatheringstatechange\", checkState);\n        clearTimeout(timeoutId);\n      };\n      const checkState = () => {\n        logger.debug(\"icegatheringstatechange:\", pc.iceGatheringState);\n        if (pc.iceGatheringState === \"complete\") {\n          cleanup();\n          resolve();\n        }\n      };\n      const onTimeout = () => {\n        logger.debug(`ICE gathering timed out after ${timeoutMs} ms.`);\n        cleanup();\n        resolve();\n      };\n      pc.addEventListener(\"icegatheringstatechange\", checkState);\n      timeoutId = setTimeout(onTimeout, timeoutMs);\n      // Checking the state again to avoid race conditions\n      checkState();\n    });\n  }\n\n  private async sendIceCandidate(candidate: RTCIceCandidate): Promise<void> {\n    if (!this._webrtcRequest) {\n      logger.error(\"No request details provided for WebRTC connection\");\n      return;\n    }\n    this._candidateQueue.push(candidate);\n    // We are sending all the ice candidates each 200ms\n    if (!this.__flushTimeout) {\n      this.__flushTimeout = setTimeout(\n        () => this.flushIceCandidates(),\n        this._flushDelay,\n      );\n    }\n  }\n\n  private async flushIceCandidates(): Promise<void> {\n    this.__flushTimeout = null;\n    if (\n      !this._webrtcRequest ||\n      this._candidateQueue.length === 0 ||\n      !this._canSendIceCandidates\n    )\n      return;\n\n    // Drain queue\n    const candidates = this._candidateQueue.splice(\n      0,\n      this._candidateQueue.length,\n    );\n\n    try {\n      const headers = new Headers({\n        \"Content-Type\": \"application/json\",\n        ...Object.fromEntries(\n          (this._webrtcRequest.headers ?? new Headers()).entries(),\n        ),\n      });\n\n      const payload = {\n        pc_id: this.pc_id,\n        candidates: candidates.map((c) => ({\n          candidate: c.candidate,\n          sdp_mid: c.sdpMid,\n          sdp_mline_index: c.sdpMLineIndex,\n        })),\n      };\n\n      await fetch(this._webrtcRequest.endpoint, {\n        method: \"PATCH\",\n        headers,\n        body: JSON.stringify(payload),\n      });\n    } catch (e) {\n      logger.error(`Failed to send ICE candidate: ${e}`);\n    }\n  }\n\n  private async negotiate(\n    recreatePeerConnection: boolean = false,\n  ): Promise<void> {\n    if (!this.pc) {\n      return Promise.reject(\"Peer connection is not initialized\");\n    }\n    if (!this._webrtcRequest) {\n      logger.error(\"No request details provided for WebRTC connection\");\n      this.state = \"error\";\n      throw new TransportStartError();\n    }\n\n    try {\n      // Create offer\n      const offer = await this.pc.createOffer();\n      await this.pc.setLocalDescription(offer);\n\n      // Wait for ICE gathering to complete\n      if (this._waitForICEGathering) {\n        await this.waitForIceGatheringComplete();\n      }\n\n      let offerSdp = this.pc!.localDescription!;\n      // Filter audio codec\n      if (this.audioCodec && this.audioCodec !== \"default\") {\n        // @ts-ignore\n        offerSdp.sdp = this.sdpFilterCodec(\n          \"audio\",\n          this.audioCodec,\n          offerSdp.sdp,\n        );\n      }\n      // Filter video codec\n      if (this.videoCodec && this.videoCodec !== \"default\") {\n        // @ts-ignore\n        offerSdp.sdp = this.sdpFilterCodec(\n          \"video\",\n          this.videoCodec,\n          offerSdp.sdp,\n        );\n      }\n\n      logger.debug(`Will create offer for peerId: ${this.pc_id}`);\n\n      // Send offer to server\n      const request = cloneDeep(this._webrtcRequest);\n      const requestData: {\n        sdp: string;\n        type: string;\n        pc_id: string | null;\n        restart_pc: boolean;\n        requestData?: any;\n      } = {\n        sdp: offerSdp.sdp,\n        type: offerSdp.type as string,\n        pc_id: this.pc_id,\n        restart_pc: recreatePeerConnection,\n      };\n      if (this._webrtcRequest.requestData) {\n        requestData.requestData = this._webrtcRequest.requestData;\n      }\n      request.requestData = requestData;\n      const answer: RTCSessionDescriptionInit = (await makeRequest(\n        request,\n      )) as RTCSessionDescriptionInit;\n\n      // @ts-ignore\n      this.pc_id = answer.pc_id;\n      // @ts-ignore\n      logger.debug(`Received answer for peer connection id ${answer.pc_id}`);\n      await this.pc!.setRemoteDescription(answer);\n    } catch (e) {\n      logger.debug(\n        `Reconnection attempt ${this.reconnectionAttempts} failed: ${e}`,\n      );\n      this.isReconnecting = false;\n      setTimeout(() => this.attemptReconnection(true), 1000 * 60 * 5); // increase to account for cold-start times and other overhead\n    }\n  }\n\n  private addInitialTransceivers() {\n    // Transceivers always appear in creation-order for both peers\n    // For now we support 3 transceivers meant to hold the following\n    // tracks in the given order:\n    // audio, video, screenVideo\n    this.pc!.addTransceiver(\"audio\", { direction: \"sendrecv\" });\n    this.pc!.addTransceiver(\"video\", { direction: \"sendrecv\" });\n    if (this.mediaManager.supportsScreenShare) {\n      // For now, we only support receiving a single video track\n      this.pc!.addTransceiver(\"video\", { direction: \"sendonly\" });\n    }\n  }\n\n  private getAudioTransceiver() {\n    // Transceivers always appear in creation-order for both peers\n    // Look at addInitialTransceivers\n    return this.pc!.getTransceivers()[AUDIO_TRANSCEIVER_INDEX];\n  }\n\n  private getVideoTransceiver() {\n    // Transceivers always appear in creation-order for both peers\n    // Look at addInitialTransceivers\n    return this.pc!.getTransceivers()[VIDEO_TRANSCEIVER_INDEX];\n  }\n\n  private getScreenVideoTransceiver() {\n    // Transceivers always appear in creation-order for both peers\n    // Look at addInitialTransceivers\n    return this.pc!.getTransceivers()[SCREEN_VIDEO_TRANSCEIVER_INDEX];\n  }\n\n  private async startNewPeerConnection(\n    recreatePeerConnection: boolean = false,\n  ) {\n    this.pc = this.createPeerConnection();\n    this.addInitialTransceivers();\n    this.dc = this.createDataChannel(\"chat\", { ordered: true });\n    await this.addUserMedia();\n    await this.negotiate(recreatePeerConnection);\n    // Sending the ice candidates\n    this._canSendIceCandidates = true;\n    await this.flushIceCandidates();\n  }\n\n  private async addUserMedia(): Promise<void> {\n    logger.debug(`addUserMedia this.tracks(): ${this.tracks()}`);\n\n    let audioTrack = this.tracks().local.audio;\n    logger.debug(`addUserMedia audioTrack: ${audioTrack}`);\n    if (audioTrack) {\n      await this.getAudioTransceiver().sender.replaceTrack(audioTrack);\n    }\n\n    let videoTrack = this.tracks().local.video;\n    logger.debug(`addUserMedia videoTrack: ${videoTrack}`);\n    if (videoTrack) {\n      await this.getVideoTransceiver().sender.replaceTrack(videoTrack);\n    }\n\n    if (this.mediaManager.supportsScreenShare) {\n      videoTrack = this.tracks().local.screenVideo;\n      logger.debug(`addUserMedia screenVideoTrack: ${videoTrack}`);\n      if (videoTrack) {\n        await this.getScreenVideoTransceiver().sender.replaceTrack(videoTrack);\n      }\n    }\n  }\n\n  // Method to handle a general message (this can be expanded for other types of messages)\n  handleMessage(message: string): void {\n    try {\n      const messageObj = JSON.parse(message); // Type is `any` initially\n      logger.debug(\"received message:\", messageObj);\n\n      // Check if it's a signalling message\n      if (messageObj.type === SIGNALLING_TYPE) {\n        void this.handleSignallingMessage(\n          messageObj as SignallingMessageObject,\n        ); // Delegate to handleSignallingMessage\n      } else {\n        // Bubble any messages with rtvi-ai label\n        if (messageObj.label === \"rtvi-ai\") {\n          this._onMessage({\n            id: messageObj.id,\n            type: messageObj.type,\n            data: messageObj.data,\n          } as RTVIMessage);\n        }\n      }\n    } catch (error) {\n      logger.error(\"Failed to parse JSON message:\", error);\n    }\n  }\n\n  // Method to handle signalling messages specifically\n  async handleSignallingMessage(\n    messageObj: SignallingMessageObject,\n  ): Promise<void> {\n    // Cast the object to the correct type after verification\n    const signallingMessage = messageObj as SignallingMessageObject;\n\n    // Handle different signalling message types\n    switch (signallingMessage.message.type) {\n      case RENEGOTIATE_TYPE:\n        void this.attemptReconnection(false);\n        break;\n      case PEER_LEFT_TYPE:\n        void this.disconnect();\n        break;\n      default:\n        logger.warn(\"Unknown signalling message:\", signallingMessage.message);\n    }\n  }\n\n  private createDataChannel(\n    label: string,\n    options: RTCDataChannelInit,\n  ): RTCDataChannel {\n    const dc = this.pc!.createDataChannel(label, options);\n\n    dc.addEventListener(\"close\", () => {\n      logger.debug(\"datachannel closed\");\n      if (this.keepAliveInterval) {\n        clearInterval(this.keepAliveInterval);\n        this.keepAliveInterval = null;\n      }\n    });\n\n    dc.addEventListener(\"open\", () => {\n      logger.debug(\"datachannel opened\");\n      if (this._connectResolved) {\n        this.syncTrackStatus();\n        this._connectResolved();\n        this._connectResolved = null;\n        this._connectFailed = null;\n      }\n      // @ts-ignore\n      this.keepAliveInterval = setInterval(() => {\n        const message = \"ping: \" + new Date().getTime();\n        dc.send(message);\n      }, 1000);\n    });\n\n    dc.addEventListener(\"message\", (evt: MessageEvent) => {\n      let message = evt.data;\n      this.handleMessage(message);\n    });\n\n    return dc;\n  }\n\n  private closePeerConnection(pc: RTCPeerConnection) {\n    pc.getTransceivers().forEach((transceiver) => {\n      if (transceiver.stop) {\n        transceiver.stop();\n      }\n    });\n\n    pc.getSenders().forEach((sender) => {\n      sender.track?.stop();\n    });\n\n    pc.close();\n  }\n\n  private async stop(): Promise<void> {\n    if (!this.pc) {\n      logger.debug(\"Peer connection is already closed or null.\");\n      return;\n    }\n\n    if (this.dc) {\n      this.dc.close();\n    }\n\n    this.closePeerConnection(this.pc);\n    this.pc = null;\n\n    await this.mediaManager.disconnect();\n\n    // For some reason after we close the peer connection, it is not triggering the listeners\n    this.pc_id = null;\n    this.reconnectionAttempts = 0;\n    this.isReconnecting = false;\n    this._callbacks.onDisconnected?.();\n\n    this._candidateQueue = [];\n    this._canSendIceCandidates = false;\n\n    if (this._connectFailed) {\n      this._connectFailed();\n    }\n    this._connectFailed = null;\n    this._connectResolved = null;\n  }\n\n  getAllMics(): Promise<MediaDeviceInfo[]> {\n    return this.mediaManager.getAllMics();\n  }\n  getAllCams(): Promise<MediaDeviceInfo[]> {\n    return this.mediaManager.getAllCams();\n  }\n  getAllSpeakers(): Promise<MediaDeviceInfo[]> {\n    return this.mediaManager.getAllSpeakers();\n  }\n\n  async updateMic(micId: string): Promise<void> {\n    return this.mediaManager.updateMic(micId);\n  }\n  updateCam(camId: string): void {\n    return this.mediaManager.updateCam(camId);\n  }\n  updateSpeaker(speakerId: string): void {\n    return this.mediaManager.updateSpeaker(speakerId);\n  }\n\n  get selectedMic(): MediaDeviceInfo | Record<string, never> {\n    return this.mediaManager.selectedMic;\n  }\n  get selectedCam(): MediaDeviceInfo | Record<string, never> {\n    return this.mediaManager.selectedCam;\n  }\n  get selectedSpeaker(): MediaDeviceInfo | Record<string, never> {\n    return this.mediaManager.selectedSpeaker;\n  }\n\n  set iceServers(iceServers: RTCIceServer[]) {\n    this._iceServers = iceServers;\n  }\n\n  get iceServers() {\n    return this._iceServers;\n  }\n\n  enableMic(enable: boolean): void {\n    this.mediaManager.enableMic(enable);\n    this.sendSignallingMessage(\n      new TrackStatusMessage(AUDIO_TRANSCEIVER_INDEX, enable),\n    );\n  }\n  enableCam(enable: boolean): void {\n    this.mediaManager.enableCam(enable);\n    this.sendSignallingMessage(\n      new TrackStatusMessage(VIDEO_TRANSCEIVER_INDEX, enable),\n    );\n  }\n  async enableScreenShare(enable: boolean): Promise<void> {\n    if (!this.mediaManager.supportsScreenShare) {\n      throw new UnsupportedFeatureError(\n        \"enableScreenShare\",\n        \"mediaManager\",\n        \"Screen sharing is not supported by the current media manager\",\n      );\n    }\n    this.mediaManager.enableScreenShare(enable);\n    this.sendSignallingMessage(\n      new TrackStatusMessage(SCREEN_VIDEO_TRANSCEIVER_INDEX, enable),\n    );\n  }\n\n  get isCamEnabled(): boolean {\n    return this.mediaManager.isCamEnabled;\n  }\n  get isMicEnabled(): boolean {\n    return this.mediaManager.isMicEnabled;\n  }\n  get isSharingScreen(): boolean {\n    return this.mediaManager.isSharingScreen;\n  }\n\n  get state(): TransportState {\n    return this._state;\n  }\n\n  set state(state: TransportState) {\n    if (this._state === state) return;\n\n    this._state = state;\n    this._callbacks.onTransportStateChanged?.(state);\n  }\n\n  tracks(): Tracks {\n    return this.mediaManager.tracks();\n  }\n\n  private sdpFilterCodec(kind: string, codec: string, realSdp: string): string {\n    const allowed: number[] = [];\n    const rtxRegex = new RegExp(\"a=fmtp:(\\\\d+) apt=(\\\\d+)\\\\r$\");\n    const codecRegex = new RegExp(\n      \"a=rtpmap:([0-9]+) \" + this.escapeRegExp(codec),\n    );\n    const videoRegex = new RegExp(\"(m=\" + kind + \" .*?)( ([0-9]+))*\\\\s*$\");\n\n    const lines = realSdp.split(\"\\n\");\n\n    let isKind = false;\n    for (let i = 0; i < lines.length; i++) {\n      if (lines[i].startsWith(\"m=\" + kind + \" \")) {\n        isKind = true;\n      } else if (lines[i].startsWith(\"m=\")) {\n        isKind = false;\n      }\n\n      if (isKind) {\n        const match = lines[i].match(codecRegex);\n        if (match) {\n          allowed.push(parseInt(match[1]));\n        }\n\n        const matchRtx = lines[i].match(rtxRegex);\n        if (matchRtx && allowed.includes(parseInt(matchRtx[2]))) {\n          allowed.push(parseInt(matchRtx[1]));\n        }\n      }\n    }\n\n    const skipRegex = \"a=(fmtp|rtcp-fb|rtpmap):([0-9]+)\";\n    let sdp = \"\";\n\n    isKind = false;\n    for (let i = 0; i < lines.length; i++) {\n      if (lines[i].startsWith(\"m=\" + kind + \" \")) {\n        isKind = true;\n      } else if (lines[i].startsWith(\"m=\")) {\n        isKind = false;\n      }\n\n      if (isKind) {\n        const skipMatch = lines[i].match(skipRegex);\n        if (skipMatch && !allowed.includes(parseInt(skipMatch[2]))) {\n          continue;\n        } else if (lines[i].match(videoRegex)) {\n          sdp += lines[i].replace(videoRegex, \"$1 \" + allowed.join(\" \")) + \"\\n\";\n        } else {\n          sdp += lines[i] + \"\\n\";\n        }\n      } else {\n        sdp += lines[i] + \"\\n\";\n      }\n    }\n\n    return sdp;\n  }\n\n  private escapeRegExp(string: string): string {\n    return string.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n  }\n}\n"],"names":[],"version":3,"file":"index.module.js.map"}